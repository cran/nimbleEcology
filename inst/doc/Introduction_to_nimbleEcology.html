<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Perry de Valpine and Ben Goldstein" />

<meta name="date" content="2021-05-03" />

<title>Introduction to nimbleEcology</title>

<script>// Hide empty <a> tag within highlighted CodeBlock for screen reader accessibility (see https://github.com/jgm/pandoc/issues/6352#issuecomment-626106786) -->
// v0.0.1
// Written by JooYoung Seo (jooyoung@psu.edu) and Atsushi Yasumoto on June 1st, 2020.

document.addEventListener('DOMContentLoaded', function() {
  const codeList = document.getElementsByClassName("sourceCode");
  for (var i = 0; i < codeList.length; i++) {
    var linkList = codeList[i].getElementsByTagName('a');
    for (var j = 0; j < linkList.length; j++) {
      if (linkList[j].innerHTML === "") {
        linkList[j].setAttribute('aria-hidden', 'true');
      }
    }
  }
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Introduction to nimbleEcology</h1>
<h4 class="author">Perry de Valpine and Ben Goldstein</h4>
<h4 class="date">2021-05-03</h4>



<p>Welcome to <code>nimbleEcology</code>. This package provides distributions that can be used in NIMBLE models for common ecological model components. These include:</p>
<ul>
<li>Cormack-Jolly-Seber (CJS) capture-recapture models.</li>
<li>Dynamic hidden Markov models (DHMMs), which are used in multi-state and multi-event capture-recapture models.</li>
<li>Occupancy models.</li>
<li>Dynamic occupancy models.</li>
<li>N-mixture models.</li>
</ul>
<div id="what-is-nimble" class="section level1">
<h1>What is nimble?</h1>
<p>NIMBLE is a system for writing hierarchical statistical models and algorithms. It is distributed as an R package <a href="https://CRAN.R-project.org/package=nimble">nimble</a>. NIMBLE stands for “Numerical Inference for statistical Models using Bayesian and Likelihood Estimation”. NIMBLE includes:</p>
<ol style="list-style-type: decimal">
<li><p>A dialect of the BUGS model language that is extensible. NIMBLE uses almost the same model code as WinBUGS, OpenBUGS, and JAGS. Being “extensible” means that it is possible to write new functions and distributions and use them in your models.</p></li>
<li><p>An algorithm library including Markov chain Monte Carlo (MCMC) and other methods.</p></li>
<li><p>A compiler that generates C++ for each model and algorithm, compiles the C++, and lets you use it from R. You don’t need to know anything about C++ to use nimble.</p></li>
</ol>
<p>More information about NIMBLE can be found at <a href="https://r-nimble.org">https://r-nimble.org</a>.</p>
<p>The paper that describes NIMBLE is <a href="https://www.tandfonline.com/doi/full/10.1080/10618600.2016.1172487">here</a>.</p>
<div id="getting-help" class="section level3">
<h3>Getting help</h3>
<p>The best way to seek user support is the nimble-users list. Information on how to join can be found at <a href="https://r-nimble.org">https://r-nimble.org</a>.</p>
</div>
</div>
<div id="the-concept-of-using-new-distributions-for-ecological-model-components." class="section level1">
<h1>The concept of using new distributions for ecological model components.</h1>
<p>The distributions provided in <code>nimbleEcology</code> let you simplify model code and the algorithms that use it, such as MCMC. For the ecological models in <code>nimbleEcology</code>, the simplification comes from removing some discrete latent states from the model and instead doing the corresponding probability (or likelihood) calculations in a specialized distribution.</p>
<p>For each of the ecological model components provided by <code>nimbleEcology</code>, here are the discrete latent states that are replaced by use of a specialized distribution:</p>
<ul>
<li>CJS (basic capture-recapture): Latent individual alive-or-dead state at each time.</li>
<li>HMM and DHMM: Latent individual state, such as location or breeding status, as well as alive-or-dead, at each time.</li>
<li>Occupancy: Latent occupancy status of a site.</li>
<li>Dynamic occupancy: latent occupancy status of a site at each time.</li>
<li>N-mixture: Latent number of individuals at a site.</li>
</ul>
<p>Before going further, let’s illustrate how <code>nimbleEcology</code> can be used for a basic occupancy model.</p>
<div id="illustration-a-simple-occupancy-model" class="section level2">
<h2>Illustration: A simple occupancy model</h2>
<p>Occupancy models are used for data from repeated visits to a set of sites, where the detection (1) or non-detection (0) of a species of interest is recorded on each visit. Define <code>y[i, j]</code> as the observation from site <code>i</code> on visit <code>j</code>. <code>y[i, j]</code> is 1 if the species was seen and 0 if not.</p>
<p>Typical code for for an occupancy model would be as follows. Naturally, this is written for <code>nimble</code>, but the same code should work for JAGS or BUGS (WinBUGS or OpenBUGS) when used as needed for those packages.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">library</span>(nimble)</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="co">#&gt; Warning: package &#39;nimble&#39; was built under R version 4.0.5</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="co">#&gt; nimble version 0.11.0 is loaded.</span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="co">#&gt; For more information on NIMBLE and a User Manual,</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="co">#&gt; please visit http://R-nimble.org.</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="co">#&gt; </span></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="co">#&gt; Attaching package: &#39;nimble&#39;</span></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="co">#&gt; The following object is masked from &#39;package:stats&#39;:</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="co">#&gt; </span></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="co">#&gt;     simulate</span></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="kw">library</span>(nimbleEcology)</span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="co">#&gt; Loading nimbleEcology. Registering the following distributions:</span></span>
<span id="cb1-13"><a href="#cb1-13"></a><span class="co">#&gt;  dOcc, dDynOcc, dCJS, dHMM, dDHMM, dNmixture.</span></span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a>occupancy_code &lt;-<span class="st"> </span><span class="kw">nimbleCode</span>({</span>
<span id="cb2-2"><a href="#cb2-2"></a>  psi <span class="op">~</span><span class="st"> </span><span class="kw">dunif</span>(<span class="dv">0</span>,<span class="dv">1</span>)</span>
<span id="cb2-3"><a href="#cb2-3"></a>  p <span class="op">~</span><span class="st"> </span><span class="kw">dunif</span> (<span class="dv">0</span>,<span class="dv">1</span>)</span>
<span id="cb2-4"><a href="#cb2-4"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>nSites) {</span>
<span id="cb2-5"><a href="#cb2-5"></a>    z[i] <span class="op">~</span><span class="st"> </span><span class="kw">dbern</span>(psi)</span>
<span id="cb2-6"><a href="#cb2-6"></a>    <span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>nVisits) {</span>
<span id="cb2-7"><a href="#cb2-7"></a>      y[i, j] <span class="op">~</span><span class="st"> </span><span class="kw">dbern</span>(z[i] <span class="op">*</span><span class="st"> </span>p)</span>
<span id="cb2-8"><a href="#cb2-8"></a>    }</span>
<span id="cb2-9"><a href="#cb2-9"></a>  }</span>
<span id="cb2-10"><a href="#cb2-10"></a>})</span></code></pre></div>
<p>In this code:</p>
<ul>
<li><code>psi</code> is occupancy probability;</li>
<li><code>p</code> is detection probability;</li>
<li><code>z[i]</code> is the latent state of whether a site is really occupied (<code>z[i]</code> = 1) or not (<code>z[i]</code> = 0);</li>
<li><code>nSites</code> is the number of sites; and</li>
<li><code>nVisits</code> is the number of sampling visits to each site.</li>
</ul>
<p>The new version of this model using <code>nimbleEcology</code>’s specialized occupancy distribution will only work in <code>nimble</code> (not JAGS or BUGS). It is:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a>occupancy_code_new &lt;-<span class="st"> </span><span class="kw">nimbleCode</span>({</span>
<span id="cb3-2"><a href="#cb3-2"></a>  psi <span class="op">~</span><span class="st"> </span><span class="kw">dunif</span>(<span class="dv">0</span>,<span class="dv">1</span>)</span>
<span id="cb3-3"><a href="#cb3-3"></a>  p <span class="op">~</span><span class="st"> </span><span class="kw">dunif</span> (<span class="dv">0</span>,<span class="dv">1</span>)</span>
<span id="cb3-4"><a href="#cb3-4"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>nSites) {</span>
<span id="cb3-5"><a href="#cb3-5"></a>    y[i, <span class="dv">1</span><span class="op">:</span>nVisits] <span class="op">~</span><span class="st"> </span><span class="kw">dOcc_s</span>(<span class="dt">probOcc =</span> psi, <span class="dt">probDetect =</span> p, <span class="dt">len =</span> nVisits)</span>
<span id="cb3-6"><a href="#cb3-6"></a>  }</span>
<span id="cb3-7"><a href="#cb3-7"></a>})</span></code></pre></div>
<p>In the new code, the vector of data from all visits to site <code>i</code>, namely <code>y[i, 1:nVisits]</code>, has its likelihood contribution calculated in one step, <code>dOcc_s</code>. This occupancy distribution calculates the total probability of the data by summing over the cases that the site is occupied or unoccupied. That means that <code>z[i]</code> is not needed in the model, and MCMC will not need to sample over <code>z[i]</code>. Details of all calculations, and discussion of the pros and cons of changing models in this way, are given later this vignette.</p>
<p>The <code>_s</code> part of <code>dOcc_s</code> means that <code>p</code> is a scalar, i.e. it does not vary with visit. If it should vary with visit, a condition sometimes described as being time-dependent, it would need to be provided as a vector, and the distribution function should be <code>dOcc_v</code>.</p>
</div>
<div id="mcmc-with-both-versions-of-the-example-occupancy-model." class="section level2">
<h2>MCMC with both versions of the example occupancy model.</h2>
<p>We can run an MCMC for this model in the following steps:</p>
<ol style="list-style-type: decimal">
<li>Build the model.</li>
<li>Configure the MCMC.</li>
<li>Build the MCMC.</li>
<li>Compile the model and MCMC.</li>
<li>Run the MCMC.</li>
<li>Extract the samples.</li>
</ol>
<p>The function <code>nimbleMCMC</code> does all of these steps for you. The function <code>runMCMC</code> does steps 5-6 for you, with convenient management of options such as discarding burn-in samples. The full set of steps allows great control over how you use a model and configure and use an MCMC. We will go through the steps 1-4 and then use <code>runMCMC</code> for steps 5-6.</p>
<p>In this example, we also need simulated data. We can use the same model to create simulated data, rather than writing separate R code for that purpose.</p>
<div id="build-the-model" class="section level4">
<h4>Build the model</h4>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a>occupancy_model &lt;-<span class="st"> </span><span class="kw">nimbleModel</span>(occupancy_code,</span>
<span id="cb4-2"><a href="#cb4-2"></a>                               <span class="dt">constants =</span> <span class="kw">list</span>(<span class="dt">nSites =</span> <span class="dv">50</span>, <span class="dt">nVisits =</span> <span class="dv">5</span>))</span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="co">#&gt; defining model...</span></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="co">#&gt; building model...</span></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="co">#&gt; running calculate on model (any error reports that follow may simply reflect missing values in model variables) ... </span></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="co">#&gt; checking model sizes and dimensions... This model is not fully initialized. This is not an error. To see which variables are not initialized, use model$initializeInfo(). For more information on model initialization, see help(modelInitialization).</span></span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="co">#&gt; model building finished.</span></span></code></pre></div>
</div>
<div id="simulate-data" class="section level4">
<h4>Simulate data</h4>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a>occupancy_model<span class="op">$</span>psi &lt;-<span class="st"> </span><span class="fl">0.7</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>occupancy_model<span class="op">$</span>p &lt;-<span class="st"> </span><span class="fl">0.15</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>simNodes &lt;-<span class="st"> </span>occupancy_model<span class="op">$</span><span class="kw">getDependencies</span>(<span class="kw">c</span>(<span class="st">&quot;psi&quot;</span>, <span class="st">&quot;p&quot;</span>), <span class="dt">self =</span> <span class="ot">FALSE</span>)</span>
<span id="cb5-4"><a href="#cb5-4"></a>occupancy_model<span class="op">$</span><span class="kw">simulate</span>(simNodes)</span>
<span id="cb5-5"><a href="#cb5-5"></a>occupancy_model<span class="op">$</span>z</span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="co">#&gt;  [1] 0 0 0 1 1 0 1 0 1 0 0 1 1 1 1 0 1 1 1 1 1 1 1 0 0 1 1 1 0 1 1 0 0 1 1 1 1 1</span></span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="co">#&gt; [39] 0 1 0 0 1 0 0 1 0 1 1 1</span></span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="kw">head</span>(occupancy_model<span class="op">$</span>y, <span class="dv">10</span>) <span class="co">## first 10 rows</span></span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="co">#&gt;       [,1] [,2] [,3] [,4] [,5]</span></span>
<span id="cb5-10"><a href="#cb5-10"></a><span class="co">#&gt;  [1,]    0    0    0    0    0</span></span>
<span id="cb5-11"><a href="#cb5-11"></a><span class="co">#&gt;  [2,]    0    0    0    0    0</span></span>
<span id="cb5-12"><a href="#cb5-12"></a><span class="co">#&gt;  [3,]    0    0    0    0    0</span></span>
<span id="cb5-13"><a href="#cb5-13"></a><span class="co">#&gt;  [4,]    0    1    0    0    0</span></span>
<span id="cb5-14"><a href="#cb5-14"></a><span class="co">#&gt;  [5,]    0    0    0    0    0</span></span>
<span id="cb5-15"><a href="#cb5-15"></a><span class="co">#&gt;  [6,]    0    0    0    0    0</span></span>
<span id="cb5-16"><a href="#cb5-16"></a><span class="co">#&gt;  [7,]    0    0    1    0    0</span></span>
<span id="cb5-17"><a href="#cb5-17"></a><span class="co">#&gt;  [8,]    0    0    0    0    0</span></span>
<span id="cb5-18"><a href="#cb5-18"></a><span class="co">#&gt;  [9,]    0    0    0    1    0</span></span>
<span id="cb5-19"><a href="#cb5-19"></a><span class="co">#&gt; [10,]    0    0    0    0    0</span></span>
<span id="cb5-20"><a href="#cb5-20"></a>occupancy_model<span class="op">$</span><span class="kw">setData</span>(<span class="st">&#39;y&#39;</span>) <span class="co">## set &quot;y&quot; as data</span></span></code></pre></div>
</div>
<div id="configure-and-build-the-mcmc" class="section level4">
<h4>Configure and build the MCMC</h4>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a>MCMCconf &lt;-<span class="st"> </span><span class="kw">configureMCMC</span>(occupancy_model)</span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="co">#&gt; ===== Monitors =====</span></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="co">#&gt; thin = 1: psi, p</span></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="co">#&gt; ===== Samplers =====</span></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="co">#&gt; binary sampler (50)</span></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="co">#&gt;   - z[]  (50 elements)</span></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="co">#&gt; RW sampler (2)</span></span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="co">#&gt;   - psi</span></span>
<span id="cb6-9"><a href="#cb6-9"></a><span class="co">#&gt;   - p</span></span>
<span id="cb6-10"><a href="#cb6-10"></a>MCMC &lt;-<span class="st"> </span><span class="kw">buildMCMC</span>(occupancy_model)</span>
<span id="cb6-11"><a href="#cb6-11"></a><span class="co">#&gt; ===== Monitors =====</span></span>
<span id="cb6-12"><a href="#cb6-12"></a><span class="co">#&gt; thin = 1: psi, p</span></span>
<span id="cb6-13"><a href="#cb6-13"></a><span class="co">#&gt; ===== Samplers =====</span></span>
<span id="cb6-14"><a href="#cb6-14"></a><span class="co">#&gt; binary sampler (50)</span></span>
<span id="cb6-15"><a href="#cb6-15"></a><span class="co">#&gt;   - z[]  (50 elements)</span></span>
<span id="cb6-16"><a href="#cb6-16"></a><span class="co">#&gt; RW sampler (2)</span></span>
<span id="cb6-17"><a href="#cb6-17"></a><span class="co">#&gt;   - psi</span></span>
<span id="cb6-18"><a href="#cb6-18"></a><span class="co">#&gt;   - p</span></span></code></pre></div>
</div>
<div id="compile-the-model-and-mcmc" class="section level4">
<h4>Compile the model and MCMC</h4>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a><span class="co">## These can be done in one step, but many people</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="co">## find it convenient to do it in two steps.</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>Coccupancy_model &lt;-<span class="st"> </span><span class="kw">compileNimble</span>(occupancy_model)</span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="co">#&gt; compiling... this may take a minute. Use &#39;showCompilerOutput = TRUE&#39; to see C++ compilation details.</span></span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="co">#&gt; compilation finished.</span></span>
<span id="cb7-6"><a href="#cb7-6"></a>CMCMC &lt;-<span class="st"> </span><span class="kw">compileNimble</span>(MCMC, <span class="dt">project =</span> occupancy_model)</span>
<span id="cb7-7"><a href="#cb7-7"></a><span class="co">#&gt; compiling... this may take a minute. Use &#39;showCompilerOutput = TRUE&#39; to see C++ compilation details.</span></span>
<span id="cb7-8"><a href="#cb7-8"></a><span class="co">#&gt; compilation finished.</span></span></code></pre></div>
</div>
<div id="run-the-mcmc-and-extract-the-samples" class="section level4">
<h4>Run the MCMC and extract the samples</h4>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a>samples &lt;-<span class="st"> </span><span class="kw">runMCMC</span>(CMCMC, <span class="dt">niter =</span> <span class="dv">10000</span>, <span class="dt">nburnin =</span> <span class="dv">500</span>, <span class="dt">thin =</span> <span class="dv">10</span>)</span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="co">#&gt; running chain 1...</span></span></code></pre></div>
</div>
<div id="do-it-all-for-the-new-version-of-the-model" class="section level3">
<h3>Do it all for the new version of the model</h3>
<p>Next we show all of the same steps, except for simulating data, using the new version of the model.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a>occupancy_model_new &lt;-<span class="st"> </span><span class="kw">nimbleModel</span>(occupancy_code_new,</span>
<span id="cb9-2"><a href="#cb9-2"></a>                                   <span class="dt">constants =</span> <span class="kw">list</span>(<span class="dt">nSites =</span> <span class="dv">50</span>, <span class="dt">nVisits =</span> <span class="dv">5</span>),</span>
<span id="cb9-3"><a href="#cb9-3"></a>                                   <span class="dt">data =</span> <span class="kw">list</span>(<span class="dt">y =</span> occupancy_model<span class="op">$</span>y),</span>
<span id="cb9-4"><a href="#cb9-4"></a>                                   <span class="dt">inits =</span> <span class="kw">list</span>(<span class="dt">psi =</span> <span class="fl">0.7</span>, <span class="dt">p =</span> <span class="fl">0.15</span>))</span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="co">#&gt; defining model...</span></span>
<span id="cb9-6"><a href="#cb9-6"></a><span class="co">#&gt; building model...</span></span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="co">#&gt; setting data and initial values...</span></span>
<span id="cb9-8"><a href="#cb9-8"></a><span class="co">#&gt; running calculate on model (any error reports that follow may simply reflect missing values in model variables) ... </span></span>
<span id="cb9-9"><a href="#cb9-9"></a><span class="co">#&gt; checking model sizes and dimensions...</span></span>
<span id="cb9-10"><a href="#cb9-10"></a><span class="co">#&gt; model building finished.</span></span>
<span id="cb9-11"><a href="#cb9-11"></a>MCMC_new &lt;-<span class="st"> </span><span class="kw">buildMCMC</span>(occupancy_model_new) <span class="co">## This will use default call to configureMCMC.</span></span>
<span id="cb9-12"><a href="#cb9-12"></a>Coccupancy_model_new &lt;-<span class="st"> </span><span class="kw">compileNimble</span>(occupancy_model_new)</span>
<span id="cb9-13"><a href="#cb9-13"></a><span class="co">#&gt; compiling... this may take a minute. Use &#39;showCompilerOutput = TRUE&#39; to see C++ compilation details.</span></span>
<span id="cb9-14"><a href="#cb9-14"></a><span class="co">#&gt; compilation finished.</span></span>
<span id="cb9-15"><a href="#cb9-15"></a>CMCMC_new &lt;-<span class="st"> </span><span class="kw">compileNimble</span>(MCMC_new, <span class="dt">project =</span> occupancy_model_new)</span>
<span id="cb9-16"><a href="#cb9-16"></a><span class="co">#&gt; compiling... this may take a minute. Use &#39;showCompilerOutput = TRUE&#39; to see C++ compilation details.</span></span>
<span id="cb9-17"><a href="#cb9-17"></a><span class="co">#&gt; compilation finished.</span></span>
<span id="cb9-18"><a href="#cb9-18"></a>samples_new &lt;-<span class="st"> </span><span class="kw">runMCMC</span>(CMCMC_new, <span class="dt">niter =</span> <span class="dv">10000</span>, <span class="dt">nburnin =</span> <span class="dv">500</span>, <span class="dt">thin =</span> <span class="dv">10</span>)</span>
<span id="cb9-19"><a href="#cb9-19"></a><span class="co">#&gt; running chain 1...</span></span></code></pre></div>
<p>The results of the two versions match closely.</p>
<p><img src="data:image/png;base64,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" /><!-- --><img src="data:image/png;base64,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" /><!-- --></p>
<p>The posterior density plots show that the familiar, conventional version of the model yields the same posterior distribution as the new version, which uses <code>dOcc_s</code>.</p>
</div>
</div>
<div id="use-the-new-version-for-something-different-maximum-likelihood-or-maximum-a-posteriori-estimation." class="section level2">
<h2>Use the new version for something different: maximum likelihood or maximum a posteriori estimation.</h2>
<p>It is useful that the new way to write the model does not have discrete latent states. Since this example also does not have other latent states or random effects, we can use it simply as a likelihood or posterior density calculator. More about how to do so can be found in the nimble User Manual. Here we illustrate making a compiled <code>nimbleFunction</code> for likelihood calculations for parameters <code>psi</code> and <code>p</code> and maximizing the likelihood using R’s <code>optim</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a>CalcLogLik &lt;-<span class="st"> </span><span class="kw">nimbleFunction</span>(</span>
<span id="cb10-2"><a href="#cb10-2"></a>  <span class="dt">setup =</span> <span class="cf">function</span>(model, nodes)</span>
<span id="cb10-3"><a href="#cb10-3"></a>    calcNodes &lt;-<span class="st"> </span>model<span class="op">$</span><span class="kw">getDependencies</span>(nodes, <span class="dt">self =</span> <span class="ot">FALSE</span>),</span>
<span id="cb10-4"><a href="#cb10-4"></a>  <span class="dt">run =</span> <span class="cf">function</span>(<span class="dt">v =</span> <span class="kw">double</span>(<span class="dv">1</span>)) {</span>
<span id="cb10-5"><a href="#cb10-5"></a>    <span class="kw">values</span>(model, nodes) &lt;&lt;-<span class="st"> </span>v</span>
<span id="cb10-6"><a href="#cb10-6"></a>    <span class="kw">return</span>(model<span class="op">$</span><span class="kw">calculate</span>(calcNodes))</span>
<span id="cb10-7"><a href="#cb10-7"></a>    <span class="kw">returnType</span>(<span class="kw">double</span>(<span class="dv">0</span>))</span>
<span id="cb10-8"><a href="#cb10-8"></a>  }</span>
<span id="cb10-9"><a href="#cb10-9"></a>)</span>
<span id="cb10-10"><a href="#cb10-10"></a>OccLogLik &lt;-<span class="st"> </span><span class="kw">CalcLogLik</span>(occupancy_model_new, <span class="kw">c</span>(<span class="st">&quot;psi&quot;</span>, <span class="st">&quot;p&quot;</span>))</span>
<span id="cb10-11"><a href="#cb10-11"></a>COccLogLik &lt;-<span class="st"> </span><span class="kw">compileNimble</span>(OccLogLik, <span class="dt">project =</span> occupancy_model_new)</span>
<span id="cb10-12"><a href="#cb10-12"></a><span class="co">#&gt; compiling... this may take a minute. Use &#39;showCompilerOutput = TRUE&#39; to see C++ compilation details.</span></span>
<span id="cb10-13"><a href="#cb10-13"></a><span class="co">#&gt; compilation finished.</span></span>
<span id="cb10-14"><a href="#cb10-14"></a><span class="kw">optim</span>(<span class="kw">c</span>(<span class="fl">0.5</span>, <span class="fl">0.5</span>), COccLogLik<span class="op">$</span>run, <span class="dt">control =</span> <span class="kw">list</span>(<span class="dt">fnscale =</span> <span class="dv">-1</span>))<span class="op">$</span>par</span>
<span id="cb10-15"><a href="#cb10-15"></a><span class="co">#&gt; [1] 0.6688595 0.1794387</span></span></code></pre></div>
</div>
</div>
<div id="distributions-provided-in-nimbleecology" class="section level1">
<h1>Distributions provided in <code>nimbleEcology</code></h1>
<p>In this section, we introduce each of the <code>nimbleEcology</code> distributions in more detail. We will summarize the calculations using mathematical notation and then describe how to use the distributions in a <code>nimble</code> model.</p>
<div id="a-note-on-static-typing" class="section level3">
<h3>A note on static typing</h3>
<p>Some distribution names are followed by a suffix indicating the type of some parameters, for example the <code>_s</code> in <code>dOcc_s</code>. NIMBLE uses a static typing system, meaning that a function must know in advance if a certain argument will be a scalar, vector, or matrix. There may be notation such as <code>sv</code> or <code>svm</code> if there are two or three parameters that can be time-independent (<code>s</code>) or time-dependent (<code>v</code> or <code>m</code>) in one or more dimensions. In general, <code>s</code> corresponds to a scalar argument, <code>v</code> to a vector argument, and <code>m</code> to a matrix argument. The order of these type indicators will correspond to the order of the relevant parameters, but always check the documentation when using a new distribution with the R function <code>?</code> (e.g., both <code>?dOcc</code> and <code>?dOcc_s</code> work).</p>
<p>The static typing requirement may be relaxed somewhat in the future.</p>
</div>
<div id="capture-recapture-dcjs" class="section level2">
<h2>Capture-recapture (dCJS)</h2>
<p>Cormack-Jolly-Seber models give the probability of a capture history for each of many individuals, conditional on first capture, based on parameters for survival and detection probability. <code>nimbleEcology</code> provides a distribution for individual capture histories, with variants for time-independent and time-dependent survival and/or detection probability. Of course, the survival and detection parameters for the CJS probability may themselves depend on other parameters and/or random effects. The rest of this summary will focus on one individual’s capture history.</p>
<p>Define <span class="math inline">\(\phi_t\)</span> as survival from time <span class="math inline">\(t\)</span> to <span class="math inline">\(t+1\)</span> and <span class="math inline">\(\mathbf{\phi} = (\phi_1, \ldots, \phi_{T-1})\)</span>, where <span class="math inline">\(T\)</span> is the length of the series. We use “time” and “sampling occasion” as synonyms in this context, so <span class="math inline">\(T\)</span> is the number of sampling occasions. (Be careful with time indexing. Sometimes you might see <span class="math inline">\(\phi_t\)</span> defined as survival from time <span class="math inline">\(t-1\)</span> to <span class="math inline">\(t\)</span>.) Define <span class="math inline">\(p_t\)</span> as detection probability at time <span class="math inline">\(t\)</span> and <span class="math inline">\(\mathbf{p} = (p_1, \ldots, p_T)\)</span>. Define the capture history as <span class="math inline">\(\mathbf{y} = y_{1:T} = (y_1, \ldots, y_T)\)</span>, where each <span class="math inline">\(y_t\)</span> is 0 or 1. The notation <span class="math inline">\(y_{i:j}\)</span> means the sequence of observations from time <span class="math inline">\(i\)</span> to time <span class="math inline">\(j\)</span>. The first observation of the capture history should always be 1: <span class="math inline">\(y_1 = 1\)</span>. The CJS probability calculations condition on this first capture.</p>
<p>There are multiple ways to write the CJS probability. We will do so in a state-space format because that leads to the more general DHMM case next. The probability of observations given parameters, <span class="math inline">\(P(\mathbf{y} | \mathbf{\phi}, \mathbf{p})\)</span>, is factored as: <span class="math display">\[
P(\mathbf{y} | \mathbf{\phi}, \mathbf{p}) = \prod_{t = 1}^{T-1} P(y_{t+1} | y_{1:t}, \mathbf{\phi}, \mathbf{p})
\]</span></p>
<p>Each factor <span class="math inline">\(P(y_{t+1} | y_{1:t}, \mathbf{\phi}, \mathbf{p})\)</span> is calculated as: <span class="math display">\[
P(y_{t+1} | y_{1:t}, \mathbf{\phi}, \mathbf{p}) = I(y_{t+1} = 1) (A_{t+1} p_{t+1}) + I(y_{t+1} = 0) (A_{t+1} (1-p_{t+1}) + (1-A_{t+1}))
\]</span> The indicator function <span class="math inline">\(I(y_t = 1)\)</span> is 1 if it <span class="math inline">\(y_t\)</span> is 1, 0 otherwise, and vice versa for <span class="math inline">\(I(y_t = 0)\)</span>. Here <span class="math inline">\(A_{t+1}\)</span> is the probability that the individual is alive at time <span class="math inline">\(t+1\)</span> given <span class="math inline">\(y_{1:t}\)</span>, the data up to the previous time. This is calculated as: <span class="math display">\[
A_{t+1} = G_{t} \phi_{t}
\]</span> where <span class="math inline">\(G_{t}\)</span> is the probability that the individual is alive at time <span class="math inline">\(t\)</span> given <span class="math inline">\(y_{1:t}\)</span>, the data up to the current time. This is calculated as: <span class="math display">\[
G_{t} = I(y_t = 1) 1 + I(y_t = 0) \frac{A_t (1-p_t)}{A_t (1-p_t) + (1-A_t)}
\]</span> The sequential calculation is initialized with <span class="math inline">\(G_1 = 1\)</span>. For time step <span class="math inline">\(t+1\)</span>, we calculate <span class="math inline">\(A_{t+1}\)</span>, then <span class="math inline">\(P(y_{t+1} | y_{1:t}, \mathbf{\phi}, \mathbf{p})\)</span>, then <span class="math inline">\(G_{t+1}\)</span>, leaving us ready for time step <span class="math inline">\(t+2\)</span>. This is a simple case of a hidden Markov model where the latent state, alive or dead, is not written explicitly.</p>
<p>In the cases with time-independent survival or capture probability, we simply drop the time indexing for the corresponding parameter.</p>
<div id="cjs-distributions-in-nimbleecology" class="section level3">
<h3>CJS distributions in <code>nimbleEcology</code></h3>
<p>CJS models are available in four distributions in <code>nimbleEcology</code>. These differ only in whether survival probability and/or capture probability are time-dependent or time-independent, yielding four combinations:</p>
<ul>
<li><code>dCJS_ss</code>: Both are time-independent (scalar).</li>
<li><code>dCJS_sv</code>: Survival is time-independent (scalar). Capture probability is time-dependent (vector).</li>
<li><code>dCJS_vs</code>: Survival is time-dependent (vector). Capture probability is time-independent (scalar).</li>
<li><code>dCJS_vv</code>: Both are time-dependent (vector).</li>
</ul>
<p>The usage for each is similar. An example for <code>dCJS_vs</code> is:</p>
<p><code>y[i, 1:T] ~ dCJS_sv(probSurvive = phi, probCapture = p[i, 1:T], len = T)</code></p>
<p>Note the following points:</p>
<ul>
<li><code>y[i, 1:T]</code> is a vector of capture history. It is written as if <code>i</code> indexes individual, but it could be any vector in any variable in the model.</li>
<li>Arguments to <code>dCJS_sv</code> are named. As in R, this is optional but helpful. Without names, the order matters.</li>
<li><code>probSurvive</code> is provided as a scalar value, assuming there is a variable called <code>phi</code>.</li>
<li>In variants where <code>probSurvive</code> is a vector (<code>dOcc_vs</code> and <code>dOcc_vv</code>), the <span class="math inline">\(t^{\mbox{th}}\)</span> element of <code>probSurvive</code> is <span class="math inline">\(\phi_t\)</span> above, namely the probability of survival from occasion <span class="math inline">\(t\)</span> to <span class="math inline">\(t+1\)</span>.</li>
<li><code>probCapture</code> is provided as a vector value, assuming there is a matrix variable called <code>p</code>. The value of <code>probCapture</code> could be any vector from any variable in the model.</li>
<li><code>probCapture[t]</code> (i.e., the <span class="math inline">\(t^{\mbox{th}}\)</span> element of <code>probCapture</code>, which is <code>p[i, t]</code> in this example) is <span class="math inline">\(p_t\)</span> above, namely the probability of capture, if alive, at time <span class="math inline">\(t\)</span>.</li>
<li>The length parameter <code>len</code> is in some cases redundant (the information could be determined by the length of other inputs), but nevertheless it is required.</li>
</ul>
</div>
</div>
<div id="hidden-markov-models-hmms-and-dynamic-hidden-markov-models-dhmms" class="section level2">
<h2>Hidden Markov models (HMMs) and Dynamic hidden Markov models (DHMMs)</h2>
<p>Hidden Markov models give the probability of detection history that can handle:</p>
<ul>
<li>Detections in different states, such as locations or breeding states,</li>
<li>Incorrect state information, such as if breeding state might not be observed correctly,</li>
<li>Probabilities of transitions between states.</li>
</ul>
<p>In a HMM, “dead” is simply another state, and “unobserved” is a possible observation. Thus, HMMs are generalizations of the CJS model. In capture-recapture, HMMs encompass multi-state and multi-event models. The HMM calculations do not condition on first capture (unlike CJS above), so the time steps below begin with probabilities of states and observation at time 1 (and “<span class="math inline">\(y_{1:0}\)</span>” is empty).</p>
<p>We again use the factorization <span class="math display">\[
P(\mathbf{y} | \mathbf{\phi}, \mathbf{p}) = \prod_{t = 1}^T P(y_{t} | y_{1:t-1}, \mathbf{\phi}, \mathbf{p})
\]</span> In the case of a HMM, <span class="math inline">\(y_t\)</span> is the observed state at time <span class="math inline">\(t\)</span>, taking an integer value. Define <span class="math inline">\(S\)</span> as the number of possible true (latent) states and <span class="math inline">\(K\)</span> as the number of possible observed states. Observed states need not correspond one-to-one to real states. For example, often there is an observed state for “unobserved”. Another example is that two real states might never be distinguishable in observations, so they may correpond to only one observed state.</p>
<p>Define <span class="math inline">\(A_{i, t}\)</span> as the probability that the individual is in state <span class="math inline">\(i\)</span> at time <span class="math inline">\(t\)</span>, given <span class="math inline">\(y_{1:t-1}\)</span>, the data up to the previous time. Define <span class="math inline">\(p_{i,j,t}\)</span> as the probability that, at time <span class="math inline">\(t\)</span>, an individual in state <span class="math inline">\(i\)</span> is observed in state <span class="math inline">\(j\)</span>. Then <span class="math inline">\(P(y_{t} | y_{1:t-1}, \mathbf{\phi}, \mathbf{p})\)</span> is calculated as: <span class="math display">\[
P(y_{t} | y_{1:t-1}, \mathbf{\phi}, \mathbf{p}) = \sum_{i=1}^S A_{i, t} p_{i, y_t, t}
\]</span> where <span class="math inline">\(j = y_t\)</span> is the observed state of the individual.</p>
<p>Define <span class="math inline">\(G_{i, t}\)</span> as the probability that the individual is in state <span class="math inline">\(i\)</span> at time <span class="math inline">\(t\)</span> given <span class="math inline">\(y_{1:t}\)</span>, the data up to the current time. Define <span class="math inline">\(\psi_{i, j, t}\)</span> as the probability that, from time <span class="math inline">\(t\)</span> to <span class="math inline">\(t+1\)</span>, an individual in state <span class="math inline">\(i\)</span> transitions to state <span class="math inline">\(j\)</span>. Then the calculation of <span class="math inline">\(A_{j,t}\)</span> for each possible state <span class="math inline">\(j\)</span> is given by: <span class="math display">\[
A_{j, t} = \sum_{i=1}^S G_{i, t-1} \psi_{i, j, t-1}, \mbox{ for } j=1,\ldots,S
\]</span></p>
<p>Finally, calculation of <span class="math inline">\(G_{i, t}\)</span> for each possible state <span class="math inline">\(i\)</span> is done by conditioning on <span class="math inline">\(y_t\)</span> as follows: <span class="math display">\[
G_{i, t} = \frac{A_{i, t} p_{i, y_t, t}}{P(y_{t} | y_{1:t-1}, \mathbf{\phi}, \mathbf{p})}, \mbox{ for } j=1,\ldots,S
\]</span></p>
<p>The calculation of the total probability of a detection history with uncertain state information starts by initializing <span class="math inline">\(A_{i, 1}\)</span> to some choice of initial (or prior) probability of being in each state before any observations are made. Then, starting with <span class="math inline">\(t = 1\)</span>, we calculate <span class="math inline">\(P(y_{t} | y_{1:t-1}, \mathbf{\phi}, \mathbf{p})\)</span>. If <span class="math inline">\(t &lt; T\)</span>, we prepare for time step <span class="math inline">\(t+1\)</span> by calculating <span class="math inline">\(G_{i, t}\)</span> for each <span class="math inline">\(i\)</span> followed by <span class="math inline">\(A_{i, t+1}\)</span> for each <span class="math inline">\(i\)</span>.</p>
<p>If the transition probabilities, <span class="math inline">\(\psi_{i, j, t}\)</span>, actually depend on <span class="math inline">\(t\)</span>, we refer to the model as “Dynamic”, namely a DHMM instead of an HMM. It may also be the case that observation probabilities <span class="math inline">\(p_{i, j, t}\)</span> depend on <span class="math inline">\(t\)</span> or not.</p>
</div>
<div id="hmm-and-dhmm-distributions-in-nimbleecology" class="section level2">
<h2>HMM and DHMM distributions in <code>nimbleEcology</code></h2>
<p>HMMs and DHMMs are available in four distributions in <code>nimbleEcology</code>. These differ only in whether transition and/or observation probabilities are time-dependent or time-independent, yielding four combinations:</p>
<ul>
<li><code>dHMM</code>: Both are time-independent.</li>
<li><code>dDHMM</code>: State transitions are time-dependent (dynamic). Observation probabilities are time-independent.</li>
<li><code>dHMMo</code>: Observation probabilities are time-dependent. State transitions are time-independent (not dynamic).</li>
<li><code>dDHMMo</code>: Both are time-dependent.</li>
</ul>
<p>In this notation, the leading <code>D</code> is for “dynamic” (time-dependent state transitions), while the trailing “o” is for “observations” being time-dependent.</p>
<p>The usage for each is similar. An example for <code>dDHMM</code> is:</p>
<p><code>y[i, 1:T] ~ dDHMM(init = initial_probs[i, 1:T], obsProb = p[1:nStates, 1:nCat], transProb = Trans[i, 1:nStates, 1:nStates, 1:(T-1)], len = T)</code></p>
<p>Note the following points:</p>
<ul>
<li>As above, this is written as if <code>i</code> indexes individuals in the model, but this is arbitrary as an example.</li>
<li><code>nStates</code> is <span class="math inline">\(S\)</span> above.</li>
<li><code>nCat</code> is <span class="math inline">\(K\)</span> above.</li>
<li><code>init[i]</code> is the initial probability of being in state <code>i</code>, namely <span class="math inline">\(A_{i, 1}\)</span> above.</li>
<li><code>obsProb[i, j]</code> (i.e., <code>p[i, j]</code> in this example) is probability of observing an individual who is truly in state <code>i</code> as being in observation state <code>j</code>. This is <span class="math inline">\(p_{i, j}\)</span> above if indexing by <span class="math inline">\(t\)</span> is not needed. If observation probabilities are time-dependent (in <code>dHMMo</code> and <code>dDHMMo</code>), then <code>obsProb[i, j, t]</code> is <span class="math inline">\(p_{i, j, t}\)</span> above.</li>
<li><code>transProb[i, j, t]</code> (i.e., <code>Trans[i, j, t]</code> in this example) is the probability that an individual who is truly in state <code>i</code> changes to state <code>j</code> during the transition from time step <code>t</code> to <code>t+1</code>. This is <span class="math inline">\(\psi_{i,j,t}\)</span> above.</li>
<li><code>len</code> is the length of the observation record, <code>T</code> in this example.</li>
<li><code>len</code> must match the length of the data, <code>y[i, 1:T]</code> in this example.</li>
<li>The dimensions of <code>obsProb</code> must be <span class="math inline">\(K \times S\)</span> in the time-independent case (<code>dHMM</code> or <code>dDHMM</code>) or <span class="math inline">\(K \times S \times T\)</span> in the time-dependent case (<code>dHMMo</code> or <code>dDHMMo</code>).</li>
<li>The dimensions of <code>transProb</code> must be <span class="math inline">\(S \times S\)</span> in the time-independent case (<code>dHMM</code> or <code>dHMMo</code>) or <span class="math inline">\(S \times S \times (T-1)\)</span> in the time-dependent case (<code>dDHMM</code> or <code>dDHMMo</code>). The last dimension is one less than <span class="math inline">\(T\)</span> because no transition to time <span class="math inline">\(T+1\)</span> is needed.</li>
</ul>
</div>
<div id="occupancy" class="section level2">
<h2>Occupancy</h2>
<p>An occupancy model gives the probability of a series of detection/non-detection records for a species during multiple visits to a site. The occupancy distributions in <code>nimbleEcology</code> give the probability of the detection history for one site, so this summary focuses on data from one site.</p>
<p>Define <span class="math inline">\(y_t\)</span> to be the observation at time <span class="math inline">\(t\)</span>, with <span class="math inline">\(y_t = 1\)</span> for a detection and <span class="math inline">\(y_t = 0\)</span> for a non-detection. Again, we use “time” as a synonym for “sampling occasion”. Again, define the vector of observations as <span class="math inline">\(\mathbf{y} = (y_1, \ldots, y_T)\)</span>, where <span class="math inline">\(T\)</span> is the number of sampling occasions.</p>
<p>Define <span class="math inline">\(\psi\)</span> as the probability that a site is occupied. Define <span class="math inline">\(p_t\)</span> as the probability of a detection on sampling occasion <span class="math inline">\(t\)</span> if the site is occupied, and <span class="math inline">\(\mathbf{p} = (p_1, \ldots, p_T)\)</span>. Then the probability of the data given the parameters is: <span class="math display">\[
P(\mathbf{y} | \psi, \mathbf{p}) = \psi \prod_{t = 1}^T p_t^{y_t} (1-p_t)^{1-y_t} + (1-\psi) I\left(\sum_{t=1}^T y_t= 0 \right)
\]</span> The indicator function usage in the last term, <span class="math inline">\(I(\cdot)\)</span>, is 1 if the given summation is 0, i.e. if no detections were made. Otherwise it is 0.</p>
<div id="occupancy-models-in-nimbleecology" class="section level3">
<h3>Occupancy models in <code>nimbleEcology</code></h3>
<p>Occupancy models are available in two distributions in <code>nimbleEcology</code>. These differ only in whether detection probability depends on time or not:</p>
<ul>
<li><code>dOcc_s</code>: Detection probability is time-independent (scalar).</li>
<li><code>dOcc_v</code>: Detection probability is time-dependent (vector).</li>
</ul>
<p>An example for <code>dOcc_v</code> is:</p>
<p><code>y[i, 1:T] ~ dOcc_v(probOcc = psi, probDetect = p[i, 1:T], len = T)</code></p>
<p>Note the following points:</p>
<ul>
<li>This is written as if <code>i</code> indexes site, but the variables could be arranged in other ways.</li>
<li><code>y[i, 1:T]</code> is the detection record.</li>
<li><code>probOcc</code> is the probability of occupancy, <span class="math inline">\(\psi\)</span> above.</li>
<li><code>probDetect</code> is the vector of detection probabilities, <span class="math inline">\(\mathbf{p}\)</span> above. In the case of <code>dOcc_s</code>, <code>probDetect</code> would be a scalar.</li>
<li><code>len</code> is the length of the detection record.</li>
</ul>
</div>
</div>
<div id="dynamic-occupancy" class="section level2">
<h2>Dynamic occupancy</h2>
<p>Dynamic occupancy models give the probability of detection records from multiple seasons (primary periods) in each of which there were multiple sampling occasions (secondary periods) at each of multiple sites. The dynamic occupancy distribution in <code>nimbleEcology</code> provides probability calculations for data from one site at a time.</p>
<p>We will use “year” for primary periods and “time” or “sampling occasion” as above for secondary periods. Define <span class="math inline">\(y_{r, t}\)</span> as the observation (1 or 0) on sampling occasion <span class="math inline">\(t\)</span> of year <span class="math inline">\(r\)</span>. Define <span class="math inline">\(\mathbf{y}_r\)</span> as the detection history in year <span class="math inline">\(r\)</span>, i.e. <span class="math inline">\(\mathbf{y}_r = (y_{r, 1}, \ldots, y_{r, T})\)</span> . Define <span class="math inline">\(\phi_t\)</span> as the probability of being occupied at time <span class="math inline">\(t+1\)</span> given the site was occupied at time <span class="math inline">\(t\)</span>, called “persistence”. Define <span class="math inline">\(\gamma_t\)</span> as the probability of being occupied at time <span class="math inline">\(t+1\)</span> given the site was unoccupied at time <span class="math inline">\(t\)</span>, called “colonization”. Define <span class="math inline">\(p_{r, t}\)</span> as the detection probability on sampling occasion <span class="math inline">\(t\)</span> of year <span class="math inline">\(r\)</span> given the site is occupied.</p>
<p>The probability of all the data given parameters is: <span class="math display">\[
P(\mathbf{y} | \mathbf{\phi}, \mathbf{\gamma}, \mathbf{p}) =  \prod_{r = 1}^R P(\mathbf{y}_{r} | \mathbf{y}_{1:r-1}, \mathbf{\phi}, \mathbf{\gamma}, \mathbf{p})
\]</span> Each factor <span class="math inline">\(P(\mathbf{y}_{r} | \mathbf{y}_{1:r-1}, \mathbf{\phi}, \mathbf{\gamma}, \mathbf{p})\)</span> is calculated as: <span class="math display">\[
P(\mathbf{y}_{r} | \mathbf{y}_{1:r-1}, \mathbf{\phi}, \mathbf{\gamma}, \mathbf{p}) = A_{r} \prod_{t = 1}^T p_{r,t}^{y_{r,t}} (1-p_{r,t})^{1-y_{r,t}} + (1-A_{r}) I\left(\sum_{t=1}^T y_{r,t} = 0 \right)
\]</span> Here <span class="math inline">\(A_r\)</span> is the probability that the site is occupied in year <span class="math inline">\(r\)</span> given observations up to the previous year <span class="math inline">\(\mathbf{y}_{1:r-1}\)</span>. Otherwise, this equation is just like the occupancy model above, except there are indices for year <span class="math inline">\(r\)</span> in many places. <span class="math inline">\(A_r\)</span> is calculated as: <span class="math display">\[
A_r = G_{r-1} \phi_{r-1} + (1-G_{r-1}) \gamma_{r-1}
\]</span> Here <span class="math inline">\(G_r\)</span> is the probability that the site is occupied given the data up to time <span class="math inline">\(r\)</span>, <span class="math inline">\(\mathbf{y}_{1:r}\)</span>. This is calculated as <span class="math display">\[
G_r = \frac{A_{r} \prod_{t = 1}^T p_{r,t}^{y_{r,t}} (1-p_{r,t})^{1-y_{r,t}}}{P(\mathbf{y}_{r} | \mathbf{y}_{1:r-1}, \mathbf{\phi}, \mathbf{\gamma}, \mathbf{p})}
\]</span></p>
<p>The sequential calculation is initiated with <span class="math inline">\(A_1\)</span>, which is natural to think of as “<span class="math inline">\(\psi_1\)</span>”, probability of occupancy in the first year. Then for year <span class="math inline">\(r\)</span>, starting with <span class="math inline">\(r = 1\)</span>, we calculate <span class="math inline">\(P(\mathbf{y}_{r} | \mathbf{y}_{1:r-1}, \mathbf{\phi}, \mathbf{\gamma}, \mathbf{p})\)</span>. If <span class="math inline">\(r &lt; R\)</span>, we calculate <span class="math inline">\(G_r\)</span> and then <span class="math inline">\(A_{r+1}\)</span>, leaving us ready to increment <span class="math inline">\(r\)</span> and iterate.</p>
<div id="dynamic-occupancy-models-in-nimbleecology" class="section level3">
<h3>Dynamic occupancy models in <code>nimbleEcology</code></h3>
<p>Dynamic occupancy models are available in twelve parameterizations in <code>nimbleEcology</code>. These differ in whether persistence, colonization, and/or detection probabilities are time-dependent, with a “s” (time-independent) and “v” (time-dependent) notation similar to the distributions above. Detection probabilities can be the same for all seasons and sampling events (“s”), constant within each season but different season to season (“v”), or time-dependent by sampling event within season (“m”), in which case a matrix argument is required. The distributions are named by <code>dDynOcc_</code> followed by three letters. Each letter indicates the typing (or dimension) of the persistence, colonization, and detection probabilities, respectively:</p>
<ul>
<li><code>dDynOcc_s**</code> functions take time-independent (scalar) persistence probabilities, while <code>dDynOcc_v**</code>functions take time-dependent (vector) persistence probabilities</li>
<li><code>dDynOcc_*s*</code> functions take time-independent (scalar) colonization probabilities, while <code>dDynOcc_*v*</code>functions take time-dependent (vector) colonization probabilities</li>
<li><code>dDynOcc_**s</code> functions take time-independent (scalar) observation probabilities, while <code>dDynOcc_**v</code> functions take observation probabilities dependent on time step (vector) and <code>dDynOcc_**m</code> functions take observation probabilities dependent on both time step and observation event (matrix)</li>
</ul>
<p>Expanding these typing possibilities gives <span class="math inline">\(2 \times 2 \times 3 = 12\)</span> total functions:</p>
<ul>
<li><code>dDynOcc_sss</code></li>
<li><code>dDynOcc_svs</code></li>
<li><code>dDynOcc_vss</code></li>
<li><code>dDynOcc_vvs</code></li>
<li><code>dDynOcc_ssv</code></li>
<li><code>dDynOcc_svv</code></li>
<li><code>dDynOcc_vsv</code></li>
<li><code>dDynOcc_vvv</code></li>
<li><code>dDynOcc_ssm</code></li>
<li><code>dDynOcc_svm</code></li>
<li><code>dDynOcc_vsm</code></li>
<li><code>dDynOcc_vvm</code></li>
</ul>
<p>An example for <code>dDynOcc_svs</code> is:</p>
<p><code>y[i, 1:T] ~ dDynOcc_svs(init = psi1[i], probPersist = phi[i], probColonize = gamma[i, 1:T], p = p, len = T)</code></p>
<p>Note the following points:</p>
<ul>
<li>As in the examples above, this is written as if <code>i</code> indexes the individual site, but the variables could be arranged in other ways.</li>
<li><code>y[i, 1:T]</code> is the detection record.</li>
<li><code>probPersist</code> is the probability of persistence, <span class="math inline">\(\phi\)</span> above.</li>
<li><code>probColonize</code> is the vector of detection probabilities, <span class="math inline">\(\mathbf{\gamma}\)</span> above. In the case of <code>dDynOcc_*s*</code>, <code>probColonize</code> would be a scalar.</li>
<li><code>len</code> is the length of the detection record.</li>
<li><code>p</code> here is a single constant value of observation probability for all samples. If <code>p</code> changed with season or season and observation event, we would need to use a different function (<code>dDynOcc_**v</code> or <code>dDynOcc_**m</code>).</li>
</ul>
</div>
</div>
<div id="n-mixture" class="section level2">
<h2>N-mixture</h2>
<p>An N-mixture model gives the probability of a set of counts from repeated visits to each of multiple sites. The N-mixture distribution in <code>nimbleEcology</code> gives probability calculations for data from one site.</p>
<p>Define <span class="math inline">\(y_t\)</span> as the number of individuals counted at the site on sampling occasion (time) <span class="math inline">\(t\)</span>. Define <span class="math inline">\(\mathbf{y} = (y_1, \ldots, y_t)\)</span>. Define <span class="math inline">\(\lambda\)</span> as the average density of individuals, such that the true number of individuals, <span class="math inline">\(N\)</span>, follows a Poisson distribution with mean <span class="math inline">\(\lambda\)</span>. Define <span class="math inline">\(p_t\)</span> to be the detection probability for a single individual at time <span class="math inline">\(t\)</span>, and <span class="math inline">\(\mathbf{p} = (p_1, \ldots, p_t)\)</span>.</p>
<p>The probability of the data given the parameters is: <span class="math display">\[
P(\mathbf{y} | \lambda, \mathbf{p}) = \sum_{N = 1}^\infty \left[ P(N | \lambda)
\prod_{t = 1}^T P(y_t | N) \right]
\]</span> where <span class="math inline">\(P(N | \lambda)\)</span> is a Poisson probability and <span class="math inline">\(P(y_t | N)\)</span> is a binomial probability. That is, <span class="math inline">\(y_t \sim \mbox{Binomial}(N, p_t)\)</span>, and the <span class="math inline">\(y_t\)</span>s are independent.</p>
<p>In practice, the summation over <span class="math inline">\(N\)</span> can start at a value greater than 0 and must be truncated at some value less than infinity. Two options are provided for the range of summation:</p>
<ol style="list-style-type: decimal">
<li>Start the summation at the largest value of <span class="math inline">\(y_t\)</span> (there must be at least this many individuals) and truncate it at a value of <span class="math inline">\(maxN\)</span> provided by the user.</li>
<li>The following heuristic can be used.</li>
</ol>
<p>If we consider a single <span class="math inline">\(y_t\)</span>, then <span class="math inline">\(N - y_t | y_t \sim \mbox{Poisson}(\lambda (1-p_t))\)</span> (<em>See opening example of Royle and Dorazio</em>). Thus, a natural upper end for the summation range of <span class="math inline">\(N\)</span> would be <span class="math inline">\(y_t\)</span> plus a very high quantile of The <span class="math inline">\(\mbox{Poisson}(\lambda (1-p_t))\)</span> distribution. For a set of observations, a natural choice would be the maximum of such values across the observation times. We use the 0.99999 quantile to be conservative.</p>
<p>Correspondingly, the summation can begin at smallest of the 0.00001 quantiles of <span class="math inline">\(N | y_t\)</span>. If <span class="math inline">\(p_t\)</span> is small, this can be considerably larger than the maximum value of <span class="math inline">\(y_t\)</span>, allowing more efficient computation.</p>
<div id="n-mixture-models-in-nimbleecology" class="section level3">
<h3>N-mixture models in <code>nimbleEcology</code></h3>
<p>Standard (binomial-Poisson) N-mixture models are available in two distributions in <code>nimbleEcology</code>. They differ in whether probability of detection is visit-dependent (vector case, corresponding to <code>dNmixture_v</code>) or visit-independent (scalar, <code>dNmixture_s</code>).</p>
<p>An example is:</p>
<p><code>y[i, 1:T] ~ dNmixture_v(lambda = lambda, p = p[1:T], minN = minN, maxN = maxN, len = T)</code></p>
<ul>
<li>As in the examples above, this is written as if <code>i</code> indexes the individual site, but the variables could be arranged in other ways.</li>
<li><code>lambda</code> is <span class="math inline">\(\lambda\)</span> above.</li>
<li><code>p[1:T]</code> is <span class="math inline">\(\mathbf{p}\)</span> above. If <span class="math inline">\(p\)</span> were constant across visits, we would use <code>dNmixture_s</code> and a scalar value of <code>p</code>.</li>
<li><code>len</code> is <span class="math inline">\(T\)</span>.</li>
<li><code>minN</code> and <code>maxN</code> provide the lower and upper bounds for the sum over Ns (option 1 above). If both are set to <code>-1</code>, bounds are chosen dynamically using quantiles of the Poisson distribution (option 2 above).</li>
</ul>
<p>Three variations of the N-mixture model are also available, in which the Poisson distribution is substituted for a negative binomial, the binomial is substituted for a beta binomial, or both are substituted. These are called <code>dNmixture_BNB_*</code>, <code>dNmixture_BBP_*</code>, and <code>dNmixture_BBNB_*</code>. Each has three suffixes: <code>_v</code> and <code>_s</code> correspond to the cases provided above, and <code>_oneObs</code> distributions are provided for the case where the data are scalar (i.e., only one observation at the site). No <code>_oneObs</code> observation is provided for the default <code>dNmixture</code> because <code>dNmixture(x[1:1], lambda, prob[1:1])</code> is equivalent to <code>dpois(x[1:1], lambda * prob[1:1])</code>.</p>
<p>These combinations lead to the following set of 11 N-mixture distributions:</p>
<ul>
<li><code>dNmixture_v</code></li>
<li><code>dNmixture_s</code></li>
<li><code>dNmixture_BNB_v</code></li>
<li><code>dNmixture_BNB_s</code></li>
<li><code>dNmixture_BNB_oneObs</code></li>
<li><code>dNmixture_BBP_v</code></li>
<li><code>dNmixture_BBP_s</code></li>
<li><code>dNmixture_BBP_oneObs</code></li>
<li><code>dNmixture_BBNB_v</code></li>
<li><code>dNmixture_BBNB_s</code></li>
<li><code>dNmixture_BBNB_oneObs</code></li>
</ul>
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
