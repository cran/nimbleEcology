<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Perry de Valpine and Ben Goldstein" />

<meta name="date" content="2024-06-26" />

<title>Introduction to nimbleEcology</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Introduction to nimbleEcology</h1>
<h4 class="author">Perry de Valpine and Ben Goldstein</h4>
<h4 class="date">2024-06-26</h4>



<p>Welcome to <code>nimbleEcology</code>. This package provides
distributions that can be used in NIMBLE models for common ecological
model components. These include:</p>
<ul>
<li>Cormack-Jolly-Seber (CJS) capture-recapture models.</li>
<li>Dynamic hidden Markov models (DHMMs), which are used in multi-state
and multi-event capture-recapture models.</li>
<li>Occupancy models.</li>
<li>Dynamic occupancy models.</li>
<li>N-mixture models.</li>
</ul>
<div id="what-is-nimble" class="section level1">
<h1>What is nimble?</h1>
<p>NIMBLE is a system for writing hierarchical statistical models and
algorithms. It is distributed as an R package <a href="https://CRAN.R-project.org/package=nimble">nimble</a>. NIMBLE
stands for “Numerical Inference for statistical Models using Bayesian
and Likelihood Estimation”. NIMBLE includes:</p>
<ol style="list-style-type: decimal">
<li><p>A dialect of the BUGS model language that is extensible. NIMBLE
uses almost the same model code as WinBUGS, OpenBUGS, and JAGS. Being
“extensible” means that it is possible to write new functions and
distributions and use them in your models.</p></li>
<li><p>An algorithm library including Markov chain Monte Carlo (MCMC)
and other methods.</p></li>
<li><p>A compiler that generates C++ for each model and algorithm,
compiles the C++, and lets you use it from R. You don’t need to know
anything about C++ to use nimble.</p></li>
</ol>
<p>More information about NIMBLE can be found at <a href="https://r-nimble.org">https://r-nimble.org</a>.</p>
<p>The paper that describes NIMBLE is <a href="https://www.tandfonline.com/doi/full/10.1080/10618600.2016.1172487">here</a>.</p>
<div id="getting-help" class="section level3">
<h3>Getting help</h3>
<p>The best way to seek user support is the nimble-users list.
Information on how to join can be found at <a href="https://r-nimble.org">https://r-nimble.org</a>.</p>
</div>
</div>
<div id="the-concept-of-using-new-distributions-for-ecological-model-components." class="section level1">
<h1>The concept of using new distributions for ecological model
components.</h1>
<p>The distributions provided in <code>nimbleEcology</code> let you
simplify model code and the algorithms that use it, such as MCMC. For
the ecological models in <code>nimbleEcology</code>, the simplification
comes from removing some discrete latent states from the model and
instead doing the corresponding probability (or likelihood) calculations
in a specialized distribution that marginalizes over the latent
states.</p>
<p>For each of the ecological model components provided by
<code>nimbleEcology</code>, here are the discrete latent states that are
replaced by use of a marginalized distribution:</p>
<ul>
<li>CJS (basic capture-recapture): Latent individual alive-or-dead state
at each time.</li>
<li>HMM and DHMM: Latent individual state, such as location or breeding
status, as well as alive-or-dead, at each time.</li>
<li>Occupancy: Latent occupancy status of a site.</li>
<li>Dynamic occupancy: Latent occupancy status of a site at each
time.</li>
<li>N-mixture: Latent number of individuals at a site.</li>
</ul>
<p>Before going further, let’s illustrate how <code>nimbleEcology</code>
can be used for a basic occupancy model.</p>
<div id="illustration-a-simple-occupancy-model" class="section level2">
<h2>Illustration: A simple occupancy model</h2>
<p>Occupancy models are used for data from repeated visits to a set of
sites, where the detection (1) or non-detection (0) of a species of
interest is recorded on each visit. Define <code>y[i, j]</code> as the
observation from site <code>i</code> on visit <code>j</code>.
<code>y[i, j]</code> is 1 if the species was seen and 0 if not.</p>
<p>Typical code for for an occupancy model would be as follows.
Naturally, this is written for <code>nimble</code>, but the same code
should work for JAGS or BUGS (WinBUGS or OpenBUGS) when used as needed
for those packages.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">library</span>(nimble)</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="co">#&gt; nimble version 1.2.0 is loaded.</span></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="co">#&gt; For more information on NIMBLE and a User Manual,</span></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="co">#&gt; please visit https://R-nimble.org.</span></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="co">#&gt; Note for advanced users who have written their own MCMC samplers:</span></span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a><span class="co">#&gt;   As of version 0.13.0, NIMBLE&#39;s protocol for handling posterior</span></span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a><span class="co">#&gt;   predictive nodes has changed in a way that could affect user-defined</span></span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a><span class="co">#&gt;   samplers in some situations. Please see Section 15.5.1 of the User Manual.</span></span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a><span class="co">#&gt; Attaching package: &#39;nimble&#39;</span></span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a><span class="co">#&gt; The following object is masked from &#39;package:stats&#39;:</span></span>
<span id="cb1-13"><a href="#cb1-13" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb1-14"><a href="#cb1-14" tabindex="-1"></a><span class="co">#&gt;     simulate</span></span>
<span id="cb1-15"><a href="#cb1-15" tabindex="-1"></a><span class="co">#&gt; The following object is masked from &#39;package:base&#39;:</span></span>
<span id="cb1-16"><a href="#cb1-16" tabindex="-1"></a><span class="co">#&gt; </span></span>
<span id="cb1-17"><a href="#cb1-17" tabindex="-1"></a><span class="co">#&gt;     declare</span></span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="fu">library</span>(nimbleEcology)</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a><span class="co">#&gt; Loading nimbleEcology. Registering multiple variants of the following distributions:</span></span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a><span class="co">#&gt;  dOcc, dDynOcc, dCJS, dHMM, dDHMM, dNmixture.</span></span></code></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>occupancy_code <span class="ot">&lt;-</span> <span class="fu">nimbleCode</span>({</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>  psi <span class="sc">~</span> <span class="fu">dunif</span>(<span class="dv">0</span>,<span class="dv">1</span>)</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>  p <span class="sc">~</span> <span class="fu">dunif</span> (<span class="dv">0</span>,<span class="dv">1</span>)</span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>nSites) {</span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>    z[i] <span class="sc">~</span> <span class="fu">dbern</span>(psi)</span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a>    <span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>nVisits) {</span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a>      y[i, j] <span class="sc">~</span> <span class="fu">dbern</span>(z[i] <span class="sc">*</span> p)</span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a>    }</span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a>  }</span>
<span id="cb3-10"><a href="#cb3-10" tabindex="-1"></a>})</span></code></pre></div>
<p>In this code:</p>
<ul>
<li><code>psi</code> is occupancy probability;</li>
<li><code>p</code> is detection probability;</li>
<li><code>z[i]</code> is the latent state of whether a site is really
occupied (<code>z[i]</code> = 1) or not (<code>z[i]</code> = 0);</li>
<li><code>nSites</code> is the number of sites; and</li>
<li><code>nVisits</code> is the number of sampling visits to each
site.</li>
</ul>
<p>The new version of this model using <code>nimbleEcology</code>’s
specialized occupancy distribution will only work in <code>nimble</code>
(not JAGS or BUGS). It is:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>occupancy_code_new <span class="ot">&lt;-</span> <span class="fu">nimbleCode</span>({</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>  psi <span class="sc">~</span> <span class="fu">dunif</span>(<span class="dv">0</span>,<span class="dv">1</span>)</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>  p <span class="sc">~</span> <span class="fu">dunif</span> (<span class="dv">0</span>,<span class="dv">1</span>)</span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>nSites) {</span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a>    y[i, <span class="dv">1</span><span class="sc">:</span>nVisits] <span class="sc">~</span> <span class="fu">dOcc_s</span>(<span class="at">probOcc =</span> psi, <span class="at">probDetect =</span> p, <span class="at">len =</span> nVisits)</span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a>  }</span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a>})</span></code></pre></div>
<p>In the new code, the vector of data from all visits to site
<code>i</code>, namely <code>y[i, 1:nVisits]</code>, has its likelihood
contribution calculated in one step, <code>dOcc_s</code>. This occupancy
distribution calculates the total probability of the data by summing
over the cases that the site is occupied or unoccupied. That means that
<code>z[i]</code> is not needed in the model, and MCMC will not need to
sample over <code>z[i]</code>. Details of all calculations, and
discussion of the pros and cons of changing models in this way, are
given later this vignette.</p>
<p>The <code>_s</code> part of <code>dOcc_s</code> means that
<code>p</code> is a scalar, i.e. it does not vary with visit. If it
should vary with visit, a condition sometimes described as being
time-dependent, it would need to be provided as a vector, and the
distribution function should be <code>dOcc_v</code>.</p>
</div>
<div id="mcmc-with-both-versions-of-the-example-occupancy-model." class="section level2">
<h2>MCMC with both versions of the example occupancy model.</h2>
<p>We can run an MCMC for this model in the following steps:</p>
<ol style="list-style-type: decimal">
<li>Build the model.</li>
<li>Configure the MCMC.</li>
<li>Build the MCMC.</li>
<li>Compile the model and MCMC.</li>
<li>Run the MCMC.</li>
<li>Extract the samples.</li>
</ol>
<p>The function <code>nimbleMCMC</code> does all of these steps for you.
The function <code>runMCMC</code> does steps 5-6 for you, with
convenient management of options such as discarding burn-in samples. The
full set of steps allows greater control over how you use a model and
configure and use an MCMC. We will go through the steps 1-4 and then use
<code>runMCMC</code> for steps 5-6.</p>
<p>In this example, we also need simulated data. We can use the same
model to create simulated data, rather than writing separate R code for
that purpose.</p>
<div id="build-the-model" class="section level4">
<h4>Build the model</h4>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>occupancy_model <span class="ot">&lt;-</span> <span class="fu">nimbleModel</span>(occupancy_code,</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>                               <span class="at">constants =</span> <span class="fu">list</span>(<span class="at">nSites =</span> <span class="dv">50</span>, <span class="at">nVisits =</span> <span class="dv">5</span>))</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a><span class="co">#&gt; Defining model</span></span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a><span class="co">#&gt; Building model</span></span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a><span class="co">#&gt; Running calculate on model</span></span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a><span class="co">#&gt;   [Note] Any error reports that follow may simply reflect missing values in model variables.</span></span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a><span class="co">#&gt; Checking model sizes and dimensions</span></span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a><span class="co">#&gt;   [Note] This model is not fully initialized. This is not an error.</span></span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a><span class="co">#&gt;          To see which variables are not initialized, use model$initializeInfo().</span></span>
<span id="cb5-10"><a href="#cb5-10" tabindex="-1"></a><span class="co">#&gt;          For more information on model initialization, see help(modelInitialization).</span></span></code></pre></div>
</div>
<div id="simulate-data" class="section level4">
<h4>Simulate data</h4>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>occupancy_model<span class="sc">$</span>psi <span class="ot">&lt;-</span> <span class="fl">0.7</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>occupancy_model<span class="sc">$</span>p <span class="ot">&lt;-</span> <span class="fl">0.15</span></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>simNodes <span class="ot">&lt;-</span> occupancy_model<span class="sc">$</span><span class="fu">getDependencies</span>(<span class="fu">c</span>(<span class="st">&quot;psi&quot;</span>, <span class="st">&quot;p&quot;</span>), <span class="at">self =</span> <span class="cn">FALSE</span>)</span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>occupancy_model<span class="sc">$</span><span class="fu">simulate</span>(simNodes)</span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a>occupancy_model<span class="sc">$</span>z</span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a><span class="co">#&gt;  [1] 0 1 0 1 1 0 1 1 1 1 1 0 1 1 1 1 0 1 0 0 1 0 0 1 0 0 1 1 1 1 1 0 1 0 0 0 0 1</span></span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a><span class="co">#&gt; [39] 1 1 1 1 1 1 1 0 1 0 1 0</span></span></code></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="fu">head</span>(occupancy_model<span class="sc">$</span>y, <span class="dv">10</span>) <span class="do">## first 10 rows</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a><span class="co">#&gt;       [,1] [,2] [,3] [,4] [,5]</span></span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a><span class="co">#&gt;  [1,]    0    0    0    0    0</span></span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a><span class="co">#&gt;  [2,]    0    0    0    0    0</span></span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a><span class="co">#&gt;  [3,]    0    0    0    0    0</span></span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a><span class="co">#&gt;  [4,]    0    0    0    0    0</span></span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a><span class="co">#&gt;  [5,]    0    0    1    0    0</span></span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a><span class="co">#&gt;  [6,]    0    0    0    0    0</span></span>
<span id="cb7-9"><a href="#cb7-9" tabindex="-1"></a><span class="co">#&gt;  [7,]    1    0    1    0    0</span></span>
<span id="cb7-10"><a href="#cb7-10" tabindex="-1"></a><span class="co">#&gt;  [8,]    0    0    0    0    0</span></span>
<span id="cb7-11"><a href="#cb7-11" tabindex="-1"></a><span class="co">#&gt;  [9,]    0    0    0    0    1</span></span>
<span id="cb7-12"><a href="#cb7-12" tabindex="-1"></a><span class="co">#&gt; [10,]    0    0    0    1    0</span></span></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>occupancy_model<span class="sc">$</span><span class="fu">setData</span>(<span class="st">&#39;y&#39;</span>) <span class="do">## set &quot;y&quot; as data</span></span></code></pre></div>
</div>
<div id="configure-and-build-the-mcmc" class="section level4">
<h4>Configure and build the MCMC</h4>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>MCMCconf <span class="ot">&lt;-</span> <span class="fu">configureMCMC</span>(occupancy_model)</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a><span class="co">#&gt; ===== Monitors =====</span></span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a><span class="co">#&gt; thin = 1: p, psi</span></span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a><span class="co">#&gt; ===== Samplers =====</span></span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a><span class="co">#&gt; binary sampler (50)</span></span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a><span class="co">#&gt;   - z[]  (50 elements)</span></span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a><span class="co">#&gt; RW sampler (2)</span></span>
<span id="cb9-8"><a href="#cb9-8" tabindex="-1"></a><span class="co">#&gt;   - psi</span></span>
<span id="cb9-9"><a href="#cb9-9" tabindex="-1"></a><span class="co">#&gt;   - p</span></span></code></pre></div>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a>MCMC <span class="ot">&lt;-</span> <span class="fu">buildMCMC</span>(occupancy_model)</span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a><span class="co">#&gt; ===== Monitors =====</span></span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a><span class="co">#&gt; thin = 1: p, psi</span></span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a><span class="co">#&gt; ===== Samplers =====</span></span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a><span class="co">#&gt; binary sampler (50)</span></span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a><span class="co">#&gt;   - z[]  (50 elements)</span></span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a><span class="co">#&gt; RW sampler (2)</span></span>
<span id="cb10-8"><a href="#cb10-8" tabindex="-1"></a><span class="co">#&gt;   - psi</span></span>
<span id="cb10-9"><a href="#cb10-9" tabindex="-1"></a><span class="co">#&gt;   - p</span></span></code></pre></div>
</div>
<div id="compile-the-model-and-mcmc" class="section level4">
<h4>Compile the model and MCMC</h4>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="do">## These can be done in one step, but many people</span></span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a><span class="do">## find it convenient to do them in two steps.</span></span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a>Coccupancy_model <span class="ot">&lt;-</span> <span class="fu">compileNimble</span>(occupancy_model)</span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a><span class="co">#&gt; Compiling</span></span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a><span class="co">#&gt;   [Note] This may take a minute.</span></span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a><span class="co">#&gt;   [Note] Use &#39;showCompilerOutput = TRUE&#39; to see C++ compilation details.</span></span></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a>CMCMC <span class="ot">&lt;-</span> <span class="fu">compileNimble</span>(MCMC, <span class="at">project =</span> occupancy_model)</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a><span class="co">#&gt; Compiling</span></span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a><span class="co">#&gt;   [Note] This may take a minute.</span></span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a><span class="co">#&gt;   [Note] Use &#39;showCompilerOutput = TRUE&#39; to see C++ compilation details.</span></span></code></pre></div>
</div>
<div id="run-the-mcmc-and-extract-the-samples" class="section level4">
<h4>Run the MCMC and extract the samples</h4>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>samples <span class="ot">&lt;-</span> <span class="fu">runMCMC</span>(CMCMC, <span class="at">niter =</span> <span class="dv">10000</span>, <span class="at">nburnin =</span> <span class="dv">500</span>, <span class="at">thin =</span> <span class="dv">10</span>)</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a><span class="co">#&gt; running chain 1...</span></span></code></pre></div>
</div>
<div id="do-it-all-for-the-new-version-of-the-model" class="section level3">
<h3>Do it all for the new version of the model</h3>
<p>Next we show all of the same steps, except for simulating data, using
the new version of the model.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a>occupancy_model_new <span class="ot">&lt;-</span> <span class="fu">nimbleModel</span>(occupancy_code_new,</span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a>                                   <span class="at">constants =</span> <span class="fu">list</span>(<span class="at">nSites =</span> <span class="dv">50</span>, <span class="at">nVisits =</span> <span class="dv">5</span>),</span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a>                                   <span class="at">data =</span> <span class="fu">list</span>(<span class="at">y =</span> occupancy_model<span class="sc">$</span>y),</span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a>                                   <span class="at">inits =</span> <span class="fu">list</span>(<span class="at">psi =</span> <span class="fl">0.7</span>, <span class="at">p =</span> <span class="fl">0.15</span>))</span>
<span id="cb14-5"><a href="#cb14-5" tabindex="-1"></a><span class="co">#&gt; Defining model</span></span>
<span id="cb14-6"><a href="#cb14-6" tabindex="-1"></a><span class="co">#&gt; Building model</span></span>
<span id="cb14-7"><a href="#cb14-7" tabindex="-1"></a><span class="co">#&gt; Setting data and initial values</span></span>
<span id="cb14-8"><a href="#cb14-8" tabindex="-1"></a><span class="co">#&gt; Running calculate on model</span></span>
<span id="cb14-9"><a href="#cb14-9" tabindex="-1"></a><span class="co">#&gt;   [Note] Any error reports that follow may simply reflect missing values in model variables.</span></span>
<span id="cb14-10"><a href="#cb14-10" tabindex="-1"></a><span class="co">#&gt; Checking model sizes and dimensions</span></span></code></pre></div>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>MCMC_new <span class="ot">&lt;-</span> <span class="fu">buildMCMC</span>(occupancy_model_new) <span class="do">## This will use default call to configureMCMC.</span></span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>Coccupancy_model_new <span class="ot">&lt;-</span> <span class="fu">compileNimble</span>(occupancy_model_new)</span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a><span class="co">#&gt; Compiling</span></span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a><span class="co">#&gt;   [Note] This may take a minute.</span></span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a><span class="co">#&gt;   [Note] Use &#39;showCompilerOutput = TRUE&#39; to see C++ compilation details.</span></span></code></pre></div>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>CMCMC_new <span class="ot">&lt;-</span> <span class="fu">compileNimble</span>(MCMC_new, <span class="at">project =</span> occupancy_model_new)</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a><span class="co">#&gt; Compiling</span></span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a><span class="co">#&gt;   [Note] This may take a minute.</span></span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a><span class="co">#&gt;   [Note] Use &#39;showCompilerOutput = TRUE&#39; to see C++ compilation details.</span></span></code></pre></div>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>samples_new <span class="ot">&lt;-</span> <span class="fu">runMCMC</span>(CMCMC_new, <span class="at">niter =</span> <span class="dv">10000</span>, <span class="at">nburnin =</span> <span class="dv">500</span>, <span class="at">thin =</span> <span class="dv">10</span>)</span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a><span class="co">#&gt; running chain 1...</span></span></code></pre></div>
<p>The results of the two versions match closely.</p>
<p><img src="data:image/png;base64,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" /><!-- --><img src="data:image/png;base64,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" /><!-- --></p>
<p>The posterior density plots show that the familiar, conventional
version of the model yields the same posterior distribution as the new
version, which uses <code>dOcc_s</code>.</p>
</div>
</div>
<div id="use-the-new-version-for-something-different-maximum-likelihood-or-maximum-a-posteriori-estimation." class="section level2">
<h2>Use the new version for something different: maximum likelihood or
maximum a posteriori estimation.</h2>
<p>It is useful that the new way to write the model does not have
discrete latent states. Since this example also does not have other
latent states or random effects, we can use it simply as a likelihood or
posterior density calculator. More about how to do so can be found in
the nimble User Manual. Here we illustrate making a compiled
<code>nimbleFunction</code> for likelihood calculations for parameters
<code>psi</code> and <code>p</code> and maximizing the likelihood using
R’s <code>optim</code>.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a>CalcLogLik <span class="ot">&lt;-</span> <span class="fu">nimbleFunction</span>(</span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a>  <span class="at">setup =</span> <span class="cf">function</span>(model, nodes)</span>
<span id="cb18-3"><a href="#cb18-3" tabindex="-1"></a>    calcNodes <span class="ot">&lt;-</span> model<span class="sc">$</span><span class="fu">getDependencies</span>(nodes, <span class="at">self =</span> <span class="cn">FALSE</span>),</span>
<span id="cb18-4"><a href="#cb18-4" tabindex="-1"></a>  <span class="at">run =</span> <span class="cf">function</span>(<span class="at">v =</span> <span class="fu">double</span>(<span class="dv">1</span>)) {</span>
<span id="cb18-5"><a href="#cb18-5" tabindex="-1"></a>    <span class="fu">values</span>(model, nodes) <span class="ot">&lt;&lt;-</span> v</span>
<span id="cb18-6"><a href="#cb18-6" tabindex="-1"></a>    <span class="fu">return</span>(model<span class="sc">$</span><span class="fu">calculate</span>(calcNodes))</span>
<span id="cb18-7"><a href="#cb18-7" tabindex="-1"></a>    <span class="fu">returnType</span>(<span class="fu">double</span>(<span class="dv">0</span>))</span>
<span id="cb18-8"><a href="#cb18-8" tabindex="-1"></a>  }</span>
<span id="cb18-9"><a href="#cb18-9" tabindex="-1"></a>)</span>
<span id="cb18-10"><a href="#cb18-10" tabindex="-1"></a>OccLogLik <span class="ot">&lt;-</span> <span class="fu">CalcLogLik</span>(occupancy_model_new, <span class="fu">c</span>(<span class="st">&quot;psi&quot;</span>, <span class="st">&quot;p&quot;</span>))</span>
<span id="cb18-11"><a href="#cb18-11" tabindex="-1"></a>COccLogLik <span class="ot">&lt;-</span> <span class="fu">compileNimble</span>(OccLogLik, <span class="at">project =</span> occupancy_model_new)</span>
<span id="cb18-12"><a href="#cb18-12" tabindex="-1"></a><span class="co">#&gt; Compiling</span></span>
<span id="cb18-13"><a href="#cb18-13" tabindex="-1"></a><span class="co">#&gt;   [Note] This may take a minute.</span></span>
<span id="cb18-14"><a href="#cb18-14" tabindex="-1"></a><span class="co">#&gt;   [Note] Use &#39;showCompilerOutput = TRUE&#39; to see C++ compilation details.</span></span></code></pre></div>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a><span class="fu">optim</span>(<span class="fu">c</span>(<span class="fl">0.5</span>, <span class="fl">0.5</span>), COccLogLik<span class="sc">$</span>run, <span class="at">control =</span> <span class="fu">list</span>(<span class="at">fnscale =</span> <span class="sc">-</span><span class="dv">1</span>))<span class="sc">$</span>par</span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a><span class="co">#&gt; [1] 0.4956485 0.1533170</span></span></code></pre></div>
</div>
<div id="support-for-automatic-differentiation-with-nimbleecology." class="section level2">
<h2>Support for automatic differentiation with
<code>nimbleEcology</code>.</h2>
<p>As of <code>nimble</code> version 1.0.0, there is a system for
automatic (or algorithmic) differentiation, known as AD. This is used by
algorithms such as Hamiltonian Monte Carlo (see package <a href="https://cran.r-project.org/package=nimbleHMC"><code>nimbleHMC</code></a>)
and Laplace approximation (<code>buildLaplace</code> in
<code>nimble</code>).</p>
<p>The distributions provided in <code>nimbleEcology</code> support AD
as much as possible. There are three main points to keep in mind:</p>
<ol style="list-style-type: decimal">
<li>It is not possible to take derivatives with respect to discrete
values, and the “data” for the <code>nimbleEcology</code> distributions
are all discrete values. It <em>is</em> possible to take derivatives
with respect to continuous parameters of the distributions. If the
“data” are marked as <code>data</code> in the model (and hence will not
be sampled by MCMC, for example), there is no problem.</li>
<li>Some values will be “baked in” to the AD calculations, meaning that
the values first present will be used permanently in later AD
calculations. In all cases of <code>nimbleEcology</code> distributions,
the values “baked in” sizes of variables. In some cases (such ash dHMM
and dDHMM) they also include the data values. See the help page for each
distribution for more details (e.g. <code>help(dOcc)</code>). If the
data are scientific data that do not need to be changed after creating
the model and algorithm, there is no problem.</li>
<li>For the N-mixture distributions only, one needs to use different
distribution names. Every <code>dNmixture</code> portion of a
distribution name below should be replaced with
<code>dNmixtureAD</code>.</li>
</ol>
</div>
</div>
<div id="distributions-provided-in-nimbleecology" class="section level1">
<h1>Distributions provided in <code>nimbleEcology</code></h1>
<p>In this section, we introduce each of the <code>nimbleEcology</code>
distributions in more detail. We will summarize the calculations using
mathematical notation and then describe how to use the distributions in
a <code>nimble</code> model.</p>
<div id="a-note-on-static-typing" class="section level3">
<h3>A note on static typing</h3>
<p>Some distribution names are followed by a suffix indicating the type
of some parameters, for example the <code>_s</code> in
<code>dOcc_s</code>. NIMBLE uses a static typing system, meaning that a
function must know in advance if a certain argument will be a scalar,
vector, or matrix. There may be notation such as <code>sv</code> or
<code>svm</code> if there are two or three parameters that can be
time-independent (<code>s</code>) or time-dependent (<code>v</code> or
<code>m</code>) in one or more dimensions. In general, <code>s</code>
corresponds to a scalar argument, <code>v</code> to a vector argument,
and <code>m</code> to a matrix argument. The order of these type
indicators will correspond to the order of the relevant parameters, but
always check the documentation when using a new distribution with the R
function <code>?</code> (e.g., both <code>?dOcc</code> and
<code>?dOcc_s</code> work).</p>
<p>The static typing requirement may be relaxed somewhat in the
future.</p>
</div>
<div id="capture-recapture-dcjs" class="section level2">
<h2>Capture-recapture (dCJS)</h2>
<p>Cormack-Jolly-Seber models give the probability of a capture history
for each of many individuals, conditional on first capture, based on
parameters for survival and detection probability.
<code>nimbleEcology</code> provides a distribution for individual
capture histories, with variants for time-independent and time-dependent
survival and/or detection probability. Of course, the survival and
detection parameters for the CJS probability may themselves depend on
other parameters and/or random effects. The rest of this summary will
focus on one individual’s capture history.</p>
<p>Define <span class="math inline">\(\phi_t\)</span> as survival from
time <span class="math inline">\(t\)</span> to <span class="math inline">\(t+1\)</span> and <span class="math inline">\(\mathbf{\phi} = (\phi_1, \ldots,
\phi_{T-1})\)</span>, where <span class="math inline">\(T\)</span> is
the length of the series. We use “time” and “sampling occasion” as
synonyms in this context, so <span class="math inline">\(T\)</span> is
the number of sampling occasions. (Be careful with time indexing.
Sometimes you might see <span class="math inline">\(\phi_t\)</span>
defined as survival from time <span class="math inline">\(t-1\)</span>
to <span class="math inline">\(t\)</span>.) Define <span class="math inline">\(p_t\)</span> as detection probability at time
<span class="math inline">\(t\)</span> and <span class="math inline">\(\mathbf{p} = (p_1, \ldots, p_T)\)</span>. Define
the capture history as <span class="math inline">\(\mathbf{y} = y_{1:T}
= (y_1, \ldots, y_T)\)</span>, where each <span class="math inline">\(y_t\)</span> is 0 or 1. The notation <span class="math inline">\(y_{i:j}\)</span> means the sequence of
observations from time <span class="math inline">\(i\)</span> to time
<span class="math inline">\(j\)</span>. The first observation of the
capture history should always be 1: <span class="math inline">\(y_1 =
1\)</span>. The CJS probability calculations condition on this first
capture.</p>
<p>There are multiple ways to write the CJS probability. We will do so
in a state-space format because that leads to the more general DHMM case
next. The probability of observations given parameters, <span class="math inline">\(P(\mathbf{y} | \mathbf{\phi},
\mathbf{p})\)</span>, is factored as: <span class="math display">\[
P(\mathbf{y} | \mathbf{\phi}, \mathbf{p}) = \prod_{t = 1}^{T-1}
P(y_{t+1} | y_{1:t}, \mathbf{\phi}, \mathbf{p})
\]</span></p>
<p>Each factor <span class="math inline">\(P(y_{t+1} | y_{1:t},
\mathbf{\phi}, \mathbf{p})\)</span> is calculated as: <span class="math display">\[
P(y_{t+1} | y_{1:t}, \mathbf{\phi}, \mathbf{p}) = I(y_{t+1} = 1)
(A_{t+1} p_{t+1}) + I(y_{t+1} = 0) (A_{t+1} (1-p_{t+1}) + (1-A_{t+1}))
\]</span> The indicator function <span class="math inline">\(I(y_t =
1)\)</span> is 1 if it <span class="math inline">\(y_t\)</span> is 1, 0
otherwise, and vice versa for <span class="math inline">\(I(y_t =
0)\)</span>. Here <span class="math inline">\(A_{t+1}\)</span> is the
probability that the individual is alive at time <span class="math inline">\(t+1\)</span> given <span class="math inline">\(y_{1:t}\)</span>, the data up to the previous
time. This is calculated as: <span class="math display">\[
A_{t+1} = G_{t} \phi_{t}
\]</span> where <span class="math inline">\(G_{t}\)</span> is the
probability that the individual is alive at time <span class="math inline">\(t\)</span> given <span class="math inline">\(y_{1:t}\)</span>, the data up to the current time.
This is calculated as: <span class="math display">\[
G_{t} = I(y_t = 1) 1 + I(y_t = 0) \frac{A_t (1-p_t)}{A_t (1-p_t) +
(1-A_t)}
\]</span> The sequential calculation is initialized with <span class="math inline">\(G_1 = 1\)</span>. For time step <span class="math inline">\(t+1\)</span>, we calculate <span class="math inline">\(A_{t+1}\)</span>, then <span class="math inline">\(P(y_{t+1} | y_{1:t}, \mathbf{\phi},
\mathbf{p})\)</span>, then <span class="math inline">\(G_{t+1}\)</span>,
leaving us ready for time step <span class="math inline">\(t+2\)</span>.
This is a simple case of a hidden Markov model where the latent state,
alive or dead, is not written explicitly.</p>
<p>In the cases with time-independent survival or capture probability,
we simply drop the time indexing for the corresponding parameter.</p>
<div id="cjs-distributions-in-nimbleecology" class="section level3">
<h3>CJS distributions in <code>nimbleEcology</code></h3>
<p>CJS models are available in four distributions in
<code>nimbleEcology</code>. These differ only in whether survival
probability and/or capture probability are time-dependent or
time-independent, yielding four combinations:</p>
<ul>
<li><code>dCJS_ss</code>: Both are time-independent (scalar).</li>
<li><code>dCJS_sv</code>: Survival is time-independent (scalar). Capture
probability is time-dependent (vector).</li>
<li><code>dCJS_vs</code>: Survival is time-dependent (vector). Capture
probability is time-independent (scalar).</li>
<li><code>dCJS_vv</code>: Both are time-dependent (vector).</li>
</ul>
<p>The usage for each is similar. An example for <code>dCJS_vs</code>
is:</p>
<p><code>y[i, 1:T] ~ dCJS_sv(probSurvive = phi, probCapture = p[i, 1:T], len = T)</code></p>
<p>Note the following points:</p>
<ul>
<li><code>y[i, 1:T]</code> is a vector of the capture history. It is
written as if <code>i</code> indexes individual, but it could be any
vector in any variable in the model.</li>
<li>Arguments to <code>dCJS_sv</code> are named. As in R, this is
optional but helpful. Without names, the order matters.</li>
<li><code>probSurvive</code> is provided as a scalar value, assuming
there is a variable called <code>phi</code>.</li>
<li>In variants where <code>probSurvive</code> is a vector
(<code>dOcc_vs</code> and <code>dOcc_vv</code>), the <span class="math inline">\(t^{\mbox{th}}\)</span> element of
<code>probSurvive</code> is <span class="math inline">\(\phi_t\)</span>
above, namely the probability of survival from occasion <span class="math inline">\(t\)</span> to <span class="math inline">\(t+1\)</span>.</li>
<li><code>probCapture</code> is provided as a vector value, assuming
there is a matrix variable called <code>p</code>. The value of
<code>probCapture</code> could be any vector from any variable in the
model.</li>
<li><code>probCapture[t]</code> (i.e., the <span class="math inline">\(t^{\mbox{th}}\)</span> element of
<code>probCapture</code>, which is <code>p[i, t]</code> in this example)
is <span class="math inline">\(p_t\)</span> above, namely the
probability of capture, if alive, at time <span class="math inline">\(t\)</span>.</li>
<li>The length parameter <code>len</code> is in some cases redundant
(the information could be determined by the length of other inputs), but
nevertheless it is required.</li>
</ul>
</div>
</div>
<div id="hidden-markov-models-hmms-and-dynamic-hidden-markov-models-dhmms" class="section level2">
<h2>Hidden Markov models (HMMs) and Dynamic hidden Markov models
(DHMMs)</h2>
<p>Hidden Markov models give the probability of detection history that
can handle:</p>
<ul>
<li>Detections in different states, such as locations or breeding
states,</li>
<li>Incorrect state information, such as if breeding state might not be
observed correctly,</li>
<li>Probabilities of transitions between states.</li>
</ul>
<p>In a HMM, “dead” is simply another state, and “unobserved” is a
possible observation. Thus, HMMs are generalizations of the CJS model.
In capture-recapture, HMMs encompass multi-state and multi-event models.
The HMM calculations do not condition on first capture (unlike CJS
above), so the time steps below begin with probabilities of states and
observation at time 1 (and “<span class="math inline">\(y_{1:0}\)</span>” is empty).</p>
<p>We again use the factorization <span class="math display">\[
P(\mathbf{y} | \mathbf{\phi}, \mathbf{p}) = \prod_{t = 1}^T P(y_{t} |
y_{1:t-1}, \mathbf{\phi}, \mathbf{p})
\]</span> In the case of a HMM, <span class="math inline">\(y_t\)</span>
is the observed state at time <span class="math inline">\(t\)</span>,
taking an integer value. Define <span class="math inline">\(S\)</span>
as the number of possible true (latent) states and <span class="math inline">\(K\)</span> as the number of possible observed
states. Observed states need not correspond one-to-one to real states.
For example, often there is an observed state for “unobserved”. Another
example is that two real states might never be distinguishable in
observations, so they may correpond to only one observed state.</p>
<p>Define <span class="math inline">\(A_{i, t}\)</span> as the
probability that the individual is in state <span class="math inline">\(i\)</span> at time <span class="math inline">\(t\)</span>, given <span class="math inline">\(y_{1:t-1}\)</span>, the data up to the previous
time. Define <span class="math inline">\(p_{i,j,t}\)</span> as the
probability that, at time <span class="math inline">\(t\)</span>, an
individual in state <span class="math inline">\(i\)</span> is observed
in state <span class="math inline">\(j\)</span>. Then <span class="math inline">\(P(y_{t} | y_{1:t-1}, \mathbf{\phi},
\mathbf{p})\)</span> is calculated as: <span class="math display">\[
P(y_{t} | y_{1:t-1}, \mathbf{\phi}, \mathbf{p}) = \sum_{i=1}^S A_{i, t}
p_{i, y_t, t}
\]</span> where <span class="math inline">\(j = y_t\)</span> is the
observed state of the individual.</p>
<p>Define <span class="math inline">\(G_{i, t}\)</span> as the
probability that the individual is in state <span class="math inline">\(i\)</span> at time <span class="math inline">\(t\)</span> given <span class="math inline">\(y_{1:t}\)</span>, the data up to the current time.
Define <span class="math inline">\(\psi_{i, j, t}\)</span> as the
probability that, from time <span class="math inline">\(t\)</span> to
<span class="math inline">\(t+1\)</span>, an individual in state <span class="math inline">\(i\)</span> transitions to state <span class="math inline">\(j\)</span>. Then the calculation of <span class="math inline">\(A_{j,t}\)</span> for each possible state <span class="math inline">\(j\)</span> is given by: <span class="math display">\[
A_{j, t} = \sum_{i=1}^S G_{i, t-1} \psi_{i, j, t-1}, \mbox{ for }
j=1,\ldots,S
\]</span></p>
<p>Finally, calculation of <span class="math inline">\(G_{i, t}\)</span>
for each possible state <span class="math inline">\(i\)</span> is done
by conditioning on <span class="math inline">\(y_t\)</span> as follows:
<span class="math display">\[
G_{i, t} = \frac{A_{i, t} p_{i, y_t, t}}{P(y_{t} | y_{1:t-1},
\mathbf{\phi}, \mathbf{p})}, \mbox{ for } j=1,\ldots,S
\]</span></p>
<p>The calculation of the total probability of a detection history with
uncertain state information starts by initializing <span class="math inline">\(A_{i, 1}\)</span> to some choice of initial (or
prior) probability of being in each state before any observations are
made. Then, starting with <span class="math inline">\(t = 1\)</span>, we
calculate <span class="math inline">\(P(y_{t} | y_{1:t-1},
\mathbf{\phi}, \mathbf{p})\)</span>. If <span class="math inline">\(t
&lt; T\)</span>, we prepare for time step <span class="math inline">\(t+1\)</span> by calculating <span class="math inline">\(G_{i, t}\)</span> for each <span class="math inline">\(i\)</span> followed by <span class="math inline">\(A_{i, t+1}\)</span> for each <span class="math inline">\(i\)</span>.</p>
<p>If the transition probabilities, <span class="math inline">\(\psi_{i,
j, t}\)</span>, actually depend on <span class="math inline">\(t\)</span>, we refer to the model as “Dynamic”,
namely a DHMM instead of an HMM. It may also be the case that
observation probabilities <span class="math inline">\(p_{i, j,
t}\)</span> depend on <span class="math inline">\(t\)</span> or not.</p>
</div>
<div id="hmm-and-dhmm-distributions-in-nimbleecology" class="section level2">
<h2>HMM and DHMM distributions in <code>nimbleEcology</code></h2>
<p>HMMs and DHMMs are available in four distributions in
<code>nimbleEcology</code>. These differ only in whether transition
and/or observation probabilities are time-dependent or time-independent,
yielding four combinations:</p>
<ul>
<li><code>dHMM</code>: Both are time-independent.</li>
<li><code>dDHMM</code>: State transitions are time-dependent (dynamic).
Observation probabilities are time-independent.</li>
<li><code>dHMMo</code>: Observation probabilities are time-dependent.
State transitions are time-independent (not dynamic).</li>
<li><code>dDHMMo</code>: Both are time-dependent.</li>
</ul>
<p>In this notation, the leading <code>D</code> is for “dynamic”
(time-dependent state transitions), while the trailing “o” is for
“observations” being time-dependent.</p>
<p>The usage for each is similar. An example for <code>dDHMM</code>
is:</p>
<p><code>y[i, 1:T] ~ dDHMM(init = initial_probs[i, 1:T], obsProb = p[1:nStates, 1:nCat], transProb = Trans[i, 1:nStates, 1:nStates, 1:(T-1)], len = T)</code></p>
<p>Note the following points:</p>
<ul>
<li>As above, this is written as if <code>i</code> indexes individuals
in the model, but this is arbitrary as an example.</li>
<li><code>nStates</code> is <span class="math inline">\(S\)</span>
above.</li>
<li><code>nCat</code> is <span class="math inline">\(K\)</span>
above.</li>
<li><code>init[i]</code> is the initial probability of being in state
<code>i</code>, namely <span class="math inline">\(A_{i, 1}\)</span>
above.</li>
<li><code>obsProb[i, j]</code> (i.e., <code>p[i, j]</code> in this
example) is probability of observing an individual who is truly in state
<code>i</code> as being in observation state <code>j</code>. This is
<span class="math inline">\(p_{i, j}\)</span> above if indexing by <span class="math inline">\(t\)</span> is not needed. If observation
probabilities are time-dependent (in <code>dHMMo</code> and
<code>dDHMMo</code>), then <code>obsProb[i, j, t]</code> is <span class="math inline">\(p_{i, j, t}\)</span> above.</li>
<li><code>transProb[i, j, t]</code> (i.e., <code>Trans[i, j, t]</code>
in this example) is the probability that an individual who is truly in
state <code>i</code> changes to state <code>j</code> during the
transition from time step <code>t</code> to <code>t+1</code>. This is
<span class="math inline">\(\psi_{i,j,t}\)</span> above.</li>
<li><code>len</code> is the length of the observation record,
<code>T</code> in this example.</li>
<li><code>len</code> must match the length of the data,
<code>y[i, 1:T]</code> in this example.</li>
<li>The dimensions of <code>obsProb</code> must be <span class="math inline">\(K \times S\)</span> in the time-independent case
(<code>dHMM</code> or <code>dDHMM</code>) or <span class="math inline">\(K \times S \times T\)</span> in the time-dependent
case (<code>dHMMo</code> or <code>dDHMMo</code>).</li>
<li>The dimensions of <code>transProb</code> must be <span class="math inline">\(S \times S\)</span> in the time-independent case
(<code>dHMM</code> or <code>dHMMo</code>) or <span class="math inline">\(S \times S \times (T-1)\)</span> in the
time-dependent case (<code>dDHMM</code> or <code>dDHMMo</code>). The
last dimension is one less than <span class="math inline">\(T\)</span>
because no transition to time <span class="math inline">\(T+1\)</span>
is needed.</li>
</ul>
</div>
<div id="occupancy" class="section level2">
<h2>Occupancy</h2>
<p>An occupancy model gives the probability of a series of
detection/non-detection records for a species during multiple visits to
a site. The occupancy distributions in <code>nimbleEcology</code> give
the probability of the detection history for one site, so this summary
focuses on data from one site.</p>
<p>Define <span class="math inline">\(y_t\)</span> to be the observation
at time <span class="math inline">\(t\)</span>, with <span class="math inline">\(y_t = 1\)</span> for a detection and <span class="math inline">\(y_t = 0\)</span> for a non-detection. Again, we
use “time” as a synonym for “sampling occasion”. Again, define the
vector of observations as <span class="math inline">\(\mathbf{y} = (y_1,
\ldots, y_T)\)</span>, where <span class="math inline">\(T\)</span> is
the number of sampling occasions.</p>
<p>Define <span class="math inline">\(\psi\)</span> as the probability
that a site is occupied. Define <span class="math inline">\(p_t\)</span>
as the probability of a detection on sampling occasion <span class="math inline">\(t\)</span> if the site is occupied, and <span class="math inline">\(\mathbf{p} = (p_1, \ldots, p_T)\)</span>. Then the
probability of the data given the parameters is: <span class="math display">\[
P(\mathbf{y} | \psi, \mathbf{p}) = \psi \prod_{t = 1}^T p_t^{y_t}
(1-p_t)^{1-y_t} + (1-\psi) I\left(\sum_{t=1}^T y_t= 0 \right)
\]</span> The indicator function usage in the last term, <span class="math inline">\(I(\cdot)\)</span>, is 1 if the given summation is
0, i.e. if no detections were made. Otherwise it is 0.</p>
<div id="occupancy-models-in-nimbleecology" class="section level3">
<h3>Occupancy models in <code>nimbleEcology</code></h3>
<p>Occupancy models are available in two distributions in
<code>nimbleEcology</code>. These differ only in whether detection
probability depends on time or not:</p>
<ul>
<li><code>dOcc_s</code>: Detection probability is time-independent
(scalar).</li>
<li><code>dOcc_v</code>: Detection probability is time-dependent
(vector).</li>
</ul>
<p>An example for <code>dOcc_v</code> is:</p>
<p><code>y[i, 1:T] ~ dOcc_v(probOcc = psi, probDetect = p[i, 1:T], len = T)</code></p>
<p>Note the following points:</p>
<ul>
<li>This is written as if <code>i</code> indexes site, but the variables
could be arranged in other ways.</li>
<li><code>y[i, 1:T]</code> is the detection record.</li>
<li><code>probOcc</code> is the probability of occupancy, <span class="math inline">\(\psi\)</span> above.</li>
<li><code>probDetect</code> is the vector of detection probabilities,
<span class="math inline">\(\mathbf{p}\)</span> above. In the case of
<code>dOcc_s</code>, <code>probDetect</code> would be a scalar.</li>
<li><code>len</code> is the length of the detection record.</li>
</ul>
</div>
</div>
<div id="dynamic-occupancy" class="section level2">
<h2>Dynamic occupancy</h2>
<p>Dynamic occupancy models give the probability of detection records
from multiple seasons (primary periods) in each of which there were
multiple sampling occasions (secondary periods) at each of multiple
sites. The dynamic occupancy distribution in <code>nimbleEcology</code>
provides probability calculations for data from one site at a time.</p>
<p>We will use “year” for primary periods and “time” or “sampling
occasion” as above for secondary periods. Define <span class="math inline">\(y_{r, t}\)</span> as the observation (1 or 0) on
sampling occasion <span class="math inline">\(t\)</span> of year <span class="math inline">\(r\)</span>. Define <span class="math inline">\(\mathbf{y}_r\)</span> as the detection history in
year <span class="math inline">\(r\)</span>, i.e. <span class="math inline">\(\mathbf{y}_r = (y_{r, 1}, \ldots, y_{r,
T})\)</span> . Define <span class="math inline">\(\phi_t\)</span> as the
probability of being occupied at time <span class="math inline">\(t+1\)</span> given the site was occupied at time
<span class="math inline">\(t\)</span>, called “persistence”. Define
<span class="math inline">\(\gamma_t\)</span> as the probability of
being occupied at time <span class="math inline">\(t+1\)</span> given
the site was unoccupied at time <span class="math inline">\(t\)</span>,
called “colonization”. Define <span class="math inline">\(p_{r,
t}\)</span> as the detection probability on sampling occasion <span class="math inline">\(t\)</span> of year <span class="math inline">\(r\)</span> given the site is occupied.</p>
<p>The probability of all the data given parameters is: <span class="math display">\[
P(\mathbf{y} | \mathbf{\phi}, \mathbf{\gamma}, \mathbf{p}) =  \prod_{r =
1}^R P(\mathbf{y}_{r} | \mathbf{y}_{1:r-1}, \mathbf{\phi},
\mathbf{\gamma}, \mathbf{p})
\]</span> Each factor <span class="math inline">\(P(\mathbf{y}_{r} |
\mathbf{y}_{1:r-1}, \mathbf{\phi}, \mathbf{\gamma}, \mathbf{p})\)</span>
is calculated as: <span class="math display">\[
P(\mathbf{y}_{r} | \mathbf{y}_{1:r-1}, \mathbf{\phi}, \mathbf{\gamma},
\mathbf{p}) = A_{r} \prod_{t = 1}^T p_{r,t}^{y_{r,t}}
(1-p_{r,t})^{1-y_{r,t}} + (1-A_{r}) I\left(\sum_{t=1}^T y_{r,t} = 0
\right)
\]</span> Here <span class="math inline">\(A_r\)</span> is the
probability that the site is occupied in year <span class="math inline">\(r\)</span> given observations up to the previous
year <span class="math inline">\(\mathbf{y}_{1:r-1}\)</span>. Otherwise,
this equation is just like the occupancy model above, except there are
indices for year <span class="math inline">\(r\)</span> in many places.
<span class="math inline">\(A_r\)</span> is calculated as: <span class="math display">\[
A_r = G_{r-1} \phi_{r-1} + (1-G_{r-1}) \gamma_{r-1}
\]</span> Here <span class="math inline">\(G_r\)</span> is the
probability that the site is occupied given the data up to time <span class="math inline">\(r\)</span>, <span class="math inline">\(\mathbf{y}_{1:r}\)</span>. This is calculated as
<span class="math display">\[
G_r = \frac{A_{r} \prod_{t = 1}^T p_{r,t}^{y_{r,t}}
(1-p_{r,t})^{1-y_{r,t}}}{P(\mathbf{y}_{r} | \mathbf{y}_{1:r-1},
\mathbf{\phi}, \mathbf{\gamma}, \mathbf{p})}
\]</span></p>
<p>The sequential calculation is initiated with <span class="math inline">\(A_1\)</span>, which is natural to think of as
“<span class="math inline">\(\psi_1\)</span>”, probability of occupancy
in the first year. Then for year <span class="math inline">\(r\)</span>,
starting with <span class="math inline">\(r = 1\)</span>, we calculate
<span class="math inline">\(P(\mathbf{y}_{r} | \mathbf{y}_{1:r-1},
\mathbf{\phi}, \mathbf{\gamma}, \mathbf{p})\)</span>. If <span class="math inline">\(r &lt; R\)</span>, we calculate <span class="math inline">\(G_r\)</span> and then <span class="math inline">\(A_{r+1}\)</span>, leaving us ready to increment
<span class="math inline">\(r\)</span> and iterate.</p>
<div id="dynamic-occupancy-models-in-nimbleecology" class="section level3">
<h3>Dynamic occupancy models in <code>nimbleEcology</code></h3>
<p>Dynamic occupancy models are available in twelve parameterizations in
<code>nimbleEcology</code>. These differ in whether persistence,
colonization, and/or detection probabilities are time-dependent, with a
“s” (time-independent) and “v” (time-dependent) notation similar to the
distributions above. Detection probabilities can be the same for all
seasons and sampling events (“s”), constant within each season but
different season to season (“v”), or time-dependent by sampling event
within season (“m”), in which case a matrix argument is required. The
distributions are named by <code>dDynOcc_</code> followed by three
letters. Each letter indicates the typing (or dimension) of the
persistence, colonization, and detection probabilities,
respectively:</p>
<ul>
<li><code>dDynOcc_s**</code> functions take time-independent (scalar)
persistence probabilities, while <code>dDynOcc_v**</code>functions take
time-dependent (vector) persistence probabilities</li>
<li><code>dDynOcc_*s*</code> functions take time-independent (scalar)
colonization probabilities, while <code>dDynOcc_*v*</code>functions take
time-dependent (vector) colonization probabilities</li>
<li><code>dDynOcc_**s</code> functions take time-independent (scalar)
observation probabilities, while <code>dDynOcc_**v</code> functions take
observation probabilities dependent on time step (vector) and
<code>dDynOcc_**m</code> functions take observation probabilities
dependent on both time step and observation event (matrix)</li>
</ul>
<p>Expanding these typing possibilities gives <span class="math inline">\(2 \times 2 \times 3 = 12\)</span> total
functions:</p>
<ul>
<li><code>dDynOcc_sss</code></li>
<li><code>dDynOcc_svs</code></li>
<li><code>dDynOcc_vss</code></li>
<li><code>dDynOcc_vvs</code></li>
<li><code>dDynOcc_ssv</code></li>
<li><code>dDynOcc_svv</code></li>
<li><code>dDynOcc_vsv</code></li>
<li><code>dDynOcc_vvv</code></li>
<li><code>dDynOcc_ssm</code></li>
<li><code>dDynOcc_svm</code></li>
<li><code>dDynOcc_vsm</code></li>
<li><code>dDynOcc_vvm</code></li>
</ul>
<p>An example for <code>dDynOcc_svs</code> is:</p>
<p><code>y[i, 1:T] ~ dDynOcc_svs(init = psi1[i], probPersist = phi[i], probColonize = gamma[i, 1:T], p = p, len = T)</code></p>
<p>Note the following points:</p>
<ul>
<li>As in the examples above, this is written as if <code>i</code>
indexes the individual site, but the variables could be arranged in
other ways.</li>
<li><code>y[i, 1:T]</code> is the detection record.</li>
<li><code>probPersist</code> is the probability of persistence, <span class="math inline">\(\phi\)</span> above.</li>
<li><code>probColonize</code> is the vector of detection probabilities,
<span class="math inline">\(\mathbf{\gamma}\)</span> above. In the case
of <code>dDynOcc_*s*</code>, <code>probColonize</code> would be a
scalar.</li>
<li><code>len</code> is the length of the detection record.</li>
<li><code>p</code> here is a single constant value of observation
probability for all samples. If <code>p</code> changed with season or
season and observation event, we would need to use a different function
(<code>dDynOcc_**v</code> or <code>dDynOcc_**m</code>).</li>
</ul>
</div>
</div>
<div id="n-mixture" class="section level2">
<h2>N-mixture</h2>
<p>An N-mixture model gives the probability of a set of counts from
repeated visits to each of multiple sites. The N-mixture distribution in
<code>nimbleEcology</code> gives probability calculations for data from
one site.</p>
<p>Define <span class="math inline">\(y_t\)</span> as the number of
individuals counted at the site on sampling occasion (time) <span class="math inline">\(t\)</span>. Define <span class="math inline">\(\mathbf{y} = (y_1, \ldots, y_t)\)</span>. Define
<span class="math inline">\(\lambda\)</span> as the average density of
individuals, such that the true number of individuals, <span class="math inline">\(N\)</span>, follows a Poisson distribution with
mean <span class="math inline">\(\lambda\)</span>. Define <span class="math inline">\(p_t\)</span> to be the detection probability for a
single individual at time <span class="math inline">\(t\)</span>, and
<span class="math inline">\(\mathbf{p} = (p_1, \ldots,
p_t)\)</span>.</p>
<p>The probability of the data given the parameters is: <span class="math display">\[
P(\mathbf{y} | \lambda, \mathbf{p}) = \sum_{N = 1}^\infty \left[ P(N |
\lambda)
\prod_{t = 1}^T P(y_t | N) \right]
\]</span> where <span class="math inline">\(P(N | \lambda)\)</span> is a
Poisson probability and <span class="math inline">\(P(y_t | N)\)</span>
is a binomial probability. That is, <span class="math inline">\(y_t \sim
\mbox{Binomial}(N, p_t)\)</span>, and the <span class="math inline">\(y_t\)</span>s are independent.</p>
<p>In practice, the summation over <span class="math inline">\(N\)</span> can start at a value greater than 0 and
must be truncated at some value less than infinity. Two options are
provided for the range of summation:</p>
<ol style="list-style-type: decimal">
<li>The user can provide values <span class="math inline">\(Nmix\)</span> and <span class="math inline">\(Nmax\)</span> to start and end the summation,
respectively. A typical choice for <span class="math inline">\(Nmin\)</span> would be the largest value of <span class="math inline">\(y_t\)</span> (there must be at least this many
individuals).</li>
<li>The following heuristic can be used:</li>
</ol>
<p>If we consider a single <span class="math inline">\(y_t\)</span>,
then <span class="math inline">\(N - y_t | y_t \sim
\mbox{Poisson}(\lambda (1-p_t))\)</span> (<em>See opening example of <a href="https://www.mbr-pwrc.usgs.gov/pubanalysis/roylebook/roylebook.html">Royle
and Dorazio, 2008</a></em>). Thus, a natural upper end for the summation
range of <span class="math inline">\(N\)</span> would be <span class="math inline">\(y_t\)</span> plus a very high quantile of The
<span class="math inline">\(\mbox{Poisson}(\lambda (1-p_t))\)</span>
distribution. For a set of observations, a natural choice would be the
maximum of such values across the observation times. We use the 0.99999
quantile to be conservative.</p>
<p>Correspondingly, the summation can begin at smallest of the 0.00001
quantiles of <span class="math inline">\(N | y_t\)</span>. If <span class="math inline">\(p_t\)</span> is small, this can be considerably
larger than the maximum value of <span class="math inline">\(y_t\)</span>, allowing more efficient
computation.</p>
<div id="n-mixture-models-in-nimbleecology" class="section level3">
<h3>N-mixture models in <code>nimbleEcology</code></h3>
<p>Standard (binomial-Poisson) N-mixture models are available in two
distributions in <code>nimbleEcology</code>. They differ in whether
probability of detection is visit-dependent (vector case, corresponding
to <code>dNmixture_v</code>) or visit-independent (scalar,
<code>dNmixture_s</code>).</p>
<p>An example is:</p>
<p><code>y[i, 1:T] ~ dNmixture_v(lambda = lambda, p = p[1:T], Nmin = Nmin, Nmax = Nmax, len = T)</code></p>
<ul>
<li>As in the examples above, this is written as if <code>i</code>
indexes the individual site, but the variables could be arranged in
other ways.</li>
<li><code>lambda</code> is <span class="math inline">\(\lambda\)</span>
above.</li>
<li><code>p[1:T]</code> is <span class="math inline">\(\mathbf{p}\)</span> above. If <span class="math inline">\(p\)</span> were constant across visits, we would
use <code>dNmixture_s</code> and a scalar value of <code>p</code>.</li>
<li><code>len</code> is <span class="math inline">\(T\)</span>.</li>
<li><code>Nmin</code> and <code>Nmax</code> provide the lower and upper
bounds for the sum over Ns (option 1 above). If both are set to
<code>-1</code>, bounds are chosen dynamically using quantiles of the
Poisson distribution (option 2 above).</li>
</ul>
<p>Three variations of the N-mixture model are also available, in which
the Poisson distribution is replaced by negative binomial, the binomial
is replaced by beta binomial, or both. These are called
<code>dNmixture_BNB_*</code>, <code>dNmixture_BBP_*</code>, and
<code>dNmixture_BBNB_*</code>, respectively. Each has three suffixes:
<code>_v</code> and <code>_s</code> correspond to the cases provided
above, and <code>_oneObs</code> distributions are provided for the case
where the data are scalar (i.e., only one observation at the site). No
<code>_oneObs</code> observation is provided for the default
<code>dNmixture</code> because
<code>dNmixture(x[1:1], lambda, prob[1:1])</code> is equivalent to
<code>dpois(x[1:1], lambda * prob[1:1])</code>.</p>
<p>These combinations lead to the following set of 11 N-mixture
distributions:</p>
<ul>
<li><code>dNmixture_v</code></li>
<li><code>dNmixture_s</code></li>
<li><code>dNmixture_BNB_v</code></li>
<li><code>dNmixture_BNB_s</code></li>
<li><code>dNmixture_BNB_oneObs</code></li>
<li><code>dNmixture_BBP_v</code></li>
<li><code>dNmixture_BBP_s</code></li>
<li><code>dNmixture_BBP_oneObs</code></li>
<li><code>dNmixture_BBNB_v</code></li>
<li><code>dNmixture_BBNB_s</code></li>
<li><code>dNmixture_BBNB_oneObs</code></li>
</ul>
<p>If an N-mixture distribution needs to be used with AD (e.g. for HMC
or Laplace approximation), replace <code>dNmixture</code> with
<code>dNmixtureAD</code>. In that case, one must provide
<code>Nmin</code> and <code>Nmax</code> values manually; the second
(heuristic) option described above is not available.</p>
<p>Further details on all the distributions in
<code>nimbleEcology</code> can be found on the help pages within R,
e.g. <code>help(dNmixture)</code>.</p>
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
